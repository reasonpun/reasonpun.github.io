---
title: C++中位运算讲解
date: 2024-08-08 09:08:30
categories:
- C++ Bit
tags:
- C++
- Bit
---

{% asset_img 1.png 示意图 width="400" %}

位运算是一种直接对二进制位进行操作的运算。位运算符在C++中非常高效，可以用于底层编程、图形处理、网络编程等场景。以下是C++中常见的位运算符及其使用方法。

### 常见的位运算符

1. **按位与运算符 (`&`)**
   - 每个位进行与操作，只有两个操作数对应位都为1时，结果位才为1。

2. **按位或运算符 (`|`)**
   - 每个位进行或操作，两个操作数中只要有一个对应位为1，结果位就为1。

3. **按位异或运算符 (`^`)**
   - 每个位进行异或操作，当两个操作数对应位不同时，结果位为1。

4. **按位取反运算符 (`~`)**
   - 对每个位取反，0变1，1变0。

5. **左移运算符 (`<<`)**
   - 将操作数的所有位左移指定的位数，右边用0填补。

6. **右移运算符 (`>>`)**
   - 将操作数的所有位右移指定的位数，左边用0填补（对于无符号数），或用符号位填补（对于有符号数）。

### 简单易懂的程序例子

下面是一些简单的C++程序例子，演示每种位运算符的使用：

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 二进制：0000 0101
    int b = 3;  // 二进制：0000 0011

    // 按位与运算
    int andResult = a & b;
    cout << "a & b = " << andResult << " (二进制: " << bitset<8>(andResult) << ")" << endl;

    // 按位或运算
    int orResult = a | b;
    cout << "a | b = " << orResult << " (二进制: " << bitset<8>(orResult) << ")" << endl;

    // 按位异或运算
    int xorResult = a ^ b;
    cout << "a ^ b = " << xorResult << " (二进制: " << bitset<8>(xorResult) << ")" << endl;

    // 按位取反运算
    int notResult = ~a;
    cout << "~a = " << notResult << " (二进制: " << bitset<8>(notResult) << ")" << endl;

    // 左移运算
    int leftShiftResult = a << 1;
    cout << "a << 1 = " << leftShiftResult << " (二进制: " << bitset<8>(leftShiftResult) << ")" << endl;

    // 右移运算
    int rightShiftResult = a >> 1;
    cout << "a >> 1 = " << rightShiftResult << " (二进制: " << bitset<8>(rightShiftResult) << ")" << endl;

    return 0;
}
```

### 结果说明

1. **按位与运算 (`&`)**
   - `a & b` 结果是1（0000 0001）
   ```cpp
   0000 0101
   & 0000 0011
   ----------
     0000 0001
   ```

2. **按位或运算 (`|`)**
   - `a | b` 结果是7（0000 0111）
   ```cpp
   0000 0101
   | 0000 0011
   ----------
     0000 0111
   ```

3. **按位异或运算 (`^`)**
   - `a ^ b` 结果是6（0000 0110）
   ```cpp
   0000 0101
   ^ 0000 0011
   ----------
     0000 0110
   ```

4. **按位取反运算 (`~`)**
   - `~a` 结果是-6（1111 1010），这里注意负数的表示是补码形式
   ```cpp
   ~0000 0101
    ----------
     1111 1010
   ```

5. **左移运算 (`<<`)**
   - `a << 1` 结果是10（0000 1010）
   ```cpp
   0000 0101
   << 1
   ----------
     0000 1010
   ```

6. **右移运算 (`>>`)**
   - `a >> 1` 结果是2（0000 0010）
   ```cpp
   0000 0105
   >> 1
   ----------
     0000 0010
   ```

### 注意事项

1. **符号扩展**：对于有符号整数，右移运算时，高位用符号位填充，这叫做算术右移；而对于无符号整数，高位用0填充，这叫做逻辑右移。
2. **溢出**：左移运算可能会导致溢出，如果移出的位中包含1，那么结果可能会变得不可预测。

### 按位与运算符 (`&`)

**原理**：对每个位进行与操作，只有两个操作数对应位都为1时，结果位才为1。

**使用场景**：常用于掩码操作，清除某些位或者保留某些位。

**例子**：
```cpp
#include <iostream>
#include <bitset>

int main() {
    int a = 6;  // 二进制：0000 0110
    int b = 3;  // 二进制：0000 0011

    int result = a & b;
    std::cout << "a & b = " << result << " (二进制: " << std::bitset<8>(result) << ")" << std::endl;
    return 0;
}
```

输出：
```
a & b = 2 (二进制: 00000010)
```

### 按位或运算符 (`|`)

**原理**：对每个位进行或操作，只要两个操作数中有一个对应位为1，结果位就为1。

**使用场景**：常用于设置某些位为1。

**例子**：
```cpp
#include <iostream>
#include <bitset>

int main() {
    int a = 6;  // 二进制：0000 0110
    int b = 3;  // 二进制：0000 0011

    int result = a | b;
    std::cout << "a | b = " << result << " (二进制: " << std::bitset<8>(result) << ")" << std::endl;
    return 0;
}
```

输出：
```
a | b = 7 (二进制: 00000111)
```

### 按位异或运算符 (`^`)

**原理**：对每个位进行异或操作，当两个操作数对应位不同时，结果位为1。

**使用场景**：常用于加密和解密操作、交换两个变量的值而不使用临时变量。

**例子**：
```cpp
#include <iostream>
#include <bitset>

int main() {
    int a = 6;  // 二进制：0000 0110
    int b = 3;  // 二进制：0000 0011

    int result = a ^ b;
    std::cout << "a ^ b = " << result << " (二进制: " << std::bitset<8>(result) << ")" << std::endl;
    return 0;
}
```

输出：
```
a ^ b = 5 (二进制: 00000101)
```

### 按位取反运算符 (`~`)

**原理**：对每个位取反，0变1，1变0。

**使用场景**：常用于生成某个值的补码，位图反转。

**例子**：
```cpp
#include <iostream>
#include <bitset>

int main() {
    int a = 6;  // 二进制：0000 0110

    int result = ~a;
    std::cout << "~a = " << result << " (二进制: " << std::bitset<8>(result) << ")" << std::endl;
    return 0;
}
```

输出：
```
~a = -7 (二进制: 11111001)
```

### 左移运算符 (`<<`)

**原理**：将操作数的所有位左移指定的位数，右边用0填补。相当于乘以2的n次方。

**使用场景**：常用于快速乘以2的幂次。

**例子**：
```cpp
#include <iostream>
#include <bitset>

int main() {
    int a = 6;  // 二进制：0000 0110

    int result = a << 2;
    std::cout << "a << 2 = " << result << " (二进制: " << std::bitset<8>(result) << ")" << std::endl;
    return 0;
}
```

输出：
```
a << 2 = 24 (二进制: 00011000)
```

### 右移运算符 (`>>`)

**原理**：将操作数的所有位右移指定的位数，左边用0填补（无符号数）或符号位填补（有符号数）。相当于除以2的n次方。

**使用场景**：常用于快速除以2的幂次。

**例子**：
```cpp
#include <iostream>
#include <bitset>

int main() {
    int a = 6;  // 二进制：0000 0110

    int result = a >> 1;
    std::cout << "a >> 1 = " << result << " (二进制: " << std::bitset<8>(result) << ")" << std::endl;
    return 0;
}
```

输出：
```
a >> 1 = 3 (二进制: 00000011)
```

### 进阶使用案例

#### 掩码操作

假设我们要从一个整数中提取某些位，比如提取第2到第4位（从0开始计数）。

```cpp
#include <iostream>
#include <bitset>

int main() {
    int a = 29;  // 二进制：0001 1101

    // 掩码：0001 1100
    int mask = 0b00011100;

    // 提取第2到第4位
    int result = (a & mask) >> 2;
    std::cout << "提取第2到第4位 = " << result << " (二进制: " << std::bitset<8>(result) << ")" << std::endl;

    return 0;
}
```

输出：
```
提取第2到第4位 = 7 (二进制: 00000111)
```

#### 交换两个变量的值

使用异或运算符可以交换两个变量的值而不使用临时变量。

```cpp
#include <iostream>

int main() {
    int a = 5;
    int b = 3;

    std::cout << "交换前: a = " << a << ", b = " << b << std::endl;

    a = a ^ b;
    b = a ^ b;
    a = a ^ b;

    std::cout << "交换后: a = " << a << ", b = " << b << std::endl;

    return 0;
}
```

输出：
```
交换前: a = 5, b = 3
交换后: a = 3, b = 5
```
