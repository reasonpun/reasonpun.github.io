<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Apache Kafka Structure | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Apache Kafka消息服务 参考地址 http:&#x2F;&#x2F;kafka.apache.org&#x2F;documentation.html  消息队列的分类  点对点 生产者生产消息发送到Queue中，消费者消费Queue中的消息，其中：  Queue中不再存储已经被消费的消息 Queue支持多个消费者，但是同一个消息，只能被一个消费者消费   发布&#x2F;订阅 生产者（生产）将消息发布到topic中，同时多个消">
<meta property="og:type" content="article">
<meta property="og:title" content="Apache Kafka Structure">
<meta property="og:url" content="http://example.com/2022/01/30/2015-12-08-apache-kafka-structure/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Apache Kafka消息服务 参考地址 http:&#x2F;&#x2F;kafka.apache.org&#x2F;documentation.html  消息队列的分类  点对点 生产者生产消息发送到Queue中，消费者消费Queue中的消息，其中：  Queue中不再存储已经被消费的消息 Queue支持多个消费者，但是同一个消息，只能被一个消费者消费   发布&#x2F;订阅 生产者（生产）将消息发布到topic中，同时多个消">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-01-30T04:24:01.486Z">
<meta property="article:modified_time" content="2022-01-30T03:40:55.628Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-2015-12-08-apache-kafka-structure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/30/2015-12-08-apache-kafka-structure/" class="article-date">
  <time class="dt-published" datetime="2022-01-30T04:24:01.486Z" itemprop="datePublished">2022-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Apache Kafka Structure
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="Apache-Kafka消息服务"><a href="#Apache-Kafka消息服务" class="headerlink" title="Apache Kafka消息服务"></a>Apache Kafka消息服务</h4><ul>
<li><p>参考地址 <a target="_blank" rel="noopener" href="http://kafka.apache.org/documentation.html#brokerconfigs">http://kafka.apache.org/documentation.html</a></p>
</li>
<li><p>消息队列的分类</p>
<ul>
<li><p>点对点</p>
<p>生产者生产消息发送到Queue中，消费者消费Queue中的消息，其中：</p>
<ul>
<li>Queue中不再存储已经被消费的消息</li>
<li>Queue支持多个消费者，但是同一个消息，只能被一个消费者消费</li>
</ul>
</li>
<li><p>发布/订阅</p>
<p>生产者（生产）将消息发布到topic中，同时多个消费者（消费）订阅该消息。和点对点方式不同的是，发布到topic的消息会被所有订阅者消费</p>
</li>
</ul>
</li>
<li><p>简介</p>
<p>背景 Kafka使用Scala语言编写，是一个分布式，分区的，支持多副本，多订阅者的日志系统。</p>
<p>目前支持Java，Python，C++， PHP等</p>
<ul>
<li>总体结构</li>
</ul>
</li>
</ul>
<p>![kafka总体结构图](/assets/images/posts/kafka.0.9.0/structure.png)</p>
<ul>
<li><p>名词解释</p>
<ul>
<li><p>Producer</p>
<p>  消息生产者，就是向kafka broker发消息的客户端</p>
</li>
<li><p>Consumer</p>
<p>  消息消费者，向kafka broker取消息的客户端</p>
</li>
<li><p>Topic</p>
<p>  是一个消息队列？</p>
</li>
<li><p>Consumer Group （CG）</p>
<ul>
<li><p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给任意一个Consumer）的手段</p>
</li>
<li><p>一个Topic可以有多个CG</p>
</li>
<li><p>Topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个consumer</p>
</li>
<li><p>如果需要实现广播，只要每个Consumer有一个独立的CG就可以了</p>
</li>
<li><p>要实现单播只要所有的Consumer在同一个CG</p>
</li>
<li><p>用CG还可以将Consumer进行自由的分组而不需要多次发送消息到不同的topic</p>
</li>
<li><p>Broker</p>
<ul>
<li>一台Kafka服务器就是一个Broker</li>
<li>一个集群由多个Broker组成。一个Broker可以容纳多个Topic</li>
</ul>
</li>
<li><p>Partition</p>
<p>为了实现扩展性，一个非常大的Topic可以分布到多个Broker（即服务器）上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列。Prtition中的每条消息都会被分配一个有序的id（Offset）。Kafka只保证按一个Partition中的顺序将消息发给Consumer，不保证一个Topic的整体（多个Partition间）的顺序。</p>
</li>
<li><p>Offset</p>
<ul>
<li>kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找</li>
<li>例如你想找位于2049的位置，只要找到2048.kafka的文件即可，当然the first offset就是00000000000.kafka</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能</li>
<li>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数十万的消息</li>
<li>支持 <em>同步</em> 和 <em>异步</em> 复制两种HA</li>
<li>Consumer客户端<ul>
<li>pull</li>
<li>随机读</li>
<li>利用sendfile系统调用</li>
<li>zero-copy</li>
<li>批量拉数据</li>
</ul>
</li>
<li>消费状态保存在客户端</li>
<li>消息存储顺序写</li>
<li>数据迁移、扩容对用户透明</li>
<li>支持Hadoop并行数据加载</li>
<li>支持online和offline的场景</li>
<li>持久化：通过将数据持久化到硬盘以及replication防止数据丢失</li>
<li>scale out：无需停机即可扩展机器</li>
<li>定期删除机制，支持设定partitions的segment file保留时间</li>
</ul>
</li>
<li><p>可靠性（一致性)</p>
<p>传统的MQ系统通常都是通过broker和consumer间的确认（ack）机制实现的，并在broker保存消息分发的状态，即使这样一致性也是很难保证的。</p>
<p>Kafka的做法是由consumer自己保存状态，也不要任何确认。这样虽然consumer负担更重，但其实更灵活了。因为不管consumer上任何原因导致需要重新处理消息，都可以再次从broker获得。</p>
</li>
<li><p>可扩展性</p>
<p>Kafka 使用Zookeeper实现动态的集群扩展，不需要更改客户端（生产者和消费者）的配置。broker会在ZK注册并保持相关的元数据更新。而客户端会在ZK上注册相关的watcher，一旦ZK发生变化，客户端能及时做出相应调整。这样可以保证变更broker时，各个broker之间能自动实现负载均衡。</p>
</li>
<li><p>设计目标</p>
<p>高吞吐量</p>
<ul>
<li>数据磁盘持久化：消息不在内存中cache，直接写入到磁盘，充分利用磁盘的顺序读写性能</li>
<li>zero-copy：减少IO操作步骤</li>
<li>支持数据批量发送和拉取</li>
<li>支持数据压缩</li>
<li>Topic划分为多个partition，提高并行处理能力</li>
</ul>
</li>
<li><p>Producer负载均衡和HA机制</p>
<ul>
<li>producer根据用户指定的算法，将消息发送到指定的partition。</li>
<li>存在多个partiiton，每个partition有自己的replica，每个replica分布在不同的Broker节点上。</li>
<li>多个partition需要选取出lead partition，lead partition负责读写，并由zookeeper负责fail over。</li>
<li>通过zookeeper管理broker与consumer的动态加入与离开。</li>
</ul>
</li>
<li><p>Consumer的pull机制</p>
<p>由于broker会持久化数据，broker没有cache压力，因此，consumer比较适合才去pull的方式消费数据：</p>
<ul>
<li>简化kafka设计，降低了难度</li>
<li>Consumer根据消费能力自主控制消息拉取速度</li>
<li>Consumer根据自身情况自主选择消费模式，例如批量，重复消费，从制定partition或位置(offset)开始消费等</li>
</ul>
</li>
<li><p>Consumer与Topic关系以及机制</p>
<p>每个group包含多个consumer。对于topic中的一条特定消息，只会被订阅此Topic每个group中的一个consumer消费，那么一个group中的所有consumer将会交错的消费整个Topic。</p>
<p>如果所有的consumer都具有相同的group（类似JMS queue），消息将有所有的consumer负载均衡</p>
<p>如果所有的consumer都具有不同的group，那么这就是『发布-订阅』，消息将会广播给所有消费者</p>
<p>在Kafka中，一个partition中的消息只会被group中的一个consumer消费（同一时刻）；每个group中consumer消息消费互相独立；<br>一个group是一个『订阅』者，一个Topic中的每个partition只会被一个『订阅』者中的一个consumer消费，但是一个consumer可以同事消费多个partitions中的消息。</p>
<p>Kafka只能保证一个partition中的消息被某个consumer消费是顺序的，但是从Topic角度，当有多个partitions时，消息仍不是全局有序的</p>
<p>一个group中包含多个consumer，这样的话不仅能提高topic中消息的并发消费能力，还能提高『故障容错』性，如果group中的某个consumer失效，那么其消费的partition将会被其他consumer接管</p>
<p>Kafka的设计原理决定，对于一个Topic，同一个group中不能有多于partition个数的consumer同时消费，否则将意味着某些consumer将无法得到消息</p>
</li>
<li><p>Producer均衡算法</p>
<p>Kafka集群中的任何一个broker，都可以向producer提供metadata，这些metadata中包含『集群中存货的servers/partition leaders』，当producer获取到metadata后，会和topic下所有的partition leader保持socker连接；消息由producer直接通过socker发送到broker</p>
<blockquote>
<p>中间不会经过任何『路由层』，即，消息被路由到哪个partition上，是有producer决定的<br>在producer端的配置文件中，可以指定partition的路由方式：『random』，『key-hash』等</p>
</blockquote>
</li>
<li><p>Consumer均衡算法</p>
<p>当一个group中，有consumer加入或者离开时，会触发partitions均衡。均衡的最终目的，是提升topic的并发消费能力。</p>
<ul>
<li>假如topic1,具有如下partitions: P0,P1,P2,P3</li>
<li>加入group中,有如下consumer: C0,C1</li>
<li>首先根据partition索引号对partitions排序: P0,P1,P2,P3</li>
<li>根据consumer.id排序: C0,C1</li>
<li>计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)</li>
<li>然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i * M),P((i + 1) * M -1)]</li>
</ul>
</li>
<li><p>Broker集群内broker之间replica机制</p>
<p>replication策略是基于partiton，而不是topic</p>
<blockquote>
<p>kafka将每个partition复制到多个server上<br>任何一个partition有一个leader和任意数量的follower<br>备份的数量可以由broker配置文件设定<br>leader处理所有的read-write请求，负责跟踪所有的follower状态，<br>如果follower『落后』太多或者失效，leader会把它从replicas同步列表中删除<br>follower需要和leader保持同步，follower就像一个consumer，消费信息并保存在本地日志中<br>当所有的follower都将一个消息保存成功，此消息才能被认为是『committed』，<br>此时consumer才能消费它，这种策略要求leader和follower之间保持良好的网络环境<br>只要ZK集群存活，即使只存活一个replica，仍可以保证消息的正常发送和接收</p>
</blockquote>
<ul>
<li>Kafka判定一个follower存活的条件<ul>
<li>和ZK保持良好的链接</li>
<li>及时跟进leader，不能落后太多</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果此replicas落后太多，它会继续在leader中fetch数据，然后加入同步列表中，<br>Kafka不会更换宿主，只有这样才能保证replicas足够快，才能保证producer发布消息时接收ACK的延迟较小</p>
</blockquote>
<ul>
<li>当leader失效，需要考虑负载均衡，partition leader较少的broker更有可能成为新的leader，因为<ul>
<li>不能采用『投票多数派』的算法，因为这种算法对于『网络稳定性/投票参与者数量』要求较高</li>
<li>Kafka集群设计中，容忍N-1个replicas失效</li>
<li>每个partiton中所有的replica信息都可以在ZK中获得，那么选择leader是非常简单的</li>
<li>选择follower时需要注意：避免新的leader server上承载的partiton leader的个数过多，否则此server将承受更多的IO压力</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>Producer端直接连接broker列表，从列表中返回TopicMetadataResponse，该Metadata包含Topic下每个partition leader建立socket连接并发送消息。</li>
<li>Broker端使用ZK用来注册broker信息，以及监控partition leader存活性。</li>
<li>Consumer端使用ZK用来注册consumer信息，其中包括consumer消费的partition列表等，同时也用来发现broker列表，并和partition leader建立socket连接，并获取消息。</li>
</ul>
</li>
</ul>
<h4 id="Kafka在Zookeeper中存储结构"><a href="#Kafka在Zookeeper中存储结构" class="headerlink" title="Kafka在Zookeeper中存储结构"></a>Kafka在Zookeeper中存储结构</h4><ul>
<li>结构图</li>
</ul>
<p>![kafka在ZK中的存储结构图](/assets/images/posts/kafka.0.9.0/kafka_in_zk.png)</p>
<h4 id="Kafka-安装和配置"><a href="#Kafka-安装和配置" class="headerlink" title="Kafka 安装和配置"></a>Kafka 安装和配置</h4><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhongwen7710/article/details/41252649">http://blog.csdn.net/zhongwen7710/article/details/41252649</a></li>
<li><a target="_blank" rel="noopener" href="http://kafka.apache.org/documentation.html#brokerconfigs">http://kafka.apache.org/documentation.html#brokerconfigs</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/30/2015-12-08-apache-kafka-structure/" data-id="ckz0rdm48000494ut9d4yc272" data-title="Apache Kafka Structure" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/01/30/2015-12-10-apache-flume-ng-structure/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Apache Flume-ng Structure
        
      </div>
    </a>
  
  
    <a href="/2022/01/30/2015-12-05-linux-shell-generate-date/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux shell 获得以前日期</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Emacs/" rel="tag">Emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/" rel="tag">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QSS/" rel="tag">QSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rails/" rel="tag">Rails</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/" rel="tag">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vagrant/" rel="tag">Vagrant</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logrotate/" rel="tag">logrotate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pyqt5/" rel="tag">pyqt5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" rel="tag">使用总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1/" rel="tag">硅谷来信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%89%BA%E6%9C%AF/" rel="tag">艺术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8B%B9%E6%9E%9C%E8%B4%A6%E5%8F%B7/" rel="tag">苹果账号</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/" rel="tag">读后感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%B7%E6%AD%8C%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">谷歌方法论</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Emacs/" style="font-size: 10px;">Emacs</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/QSS/" style="font-size: 10px;">QSS</a> <a href="/tags/Rails/" style="font-size: 10px;">Rails</a> <a href="/tags/Ruby/" style="font-size: 10px;">Ruby</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Vagrant/" style="font-size: 10px;">Vagrant</a> <a href="/tags/logrotate/" style="font-size: 10px;">logrotate</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/pyqt5/" style="font-size: 10px;">pyqt5</a> <a href="/tags/%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" style="font-size: 10px;">使用总结</a> <a href="/tags/%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1/" style="font-size: 20px;">硅谷来信</a> <a href="/tags/%E8%89%BA%E6%9C%AF/" style="font-size: 10px;">艺术</a> <a href="/tags/%E8%8B%B9%E6%9E%9C%E8%B4%A6%E5%8F%B7/" style="font-size: 10px;">苹果账号</a> <a href="/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/" style="font-size: 20px;">读后感</a> <a href="/tags/%E8%B0%B7%E6%AD%8C%E6%96%B9%E6%B3%95%E8%AE%BA/" style="font-size: 10px;">谷歌方法论</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/30/2019-03-22-%E5%90%B4%E5%86%9B-%E8%B0%B7%E6%AD%8C%E6%96%B9%E6%B3%95%E8%AE%BA-%E8%AF%AD%E6%96%87%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%84%8F%E4%B9%89/">读 吴军《谷歌方法论》- 为什么学习语文</a>
          </li>
        
          <li>
            <a href="/2022/01/30/2019-03-16-pyqt5-QSS%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/">Pyqt5 QSS</a>
          </li>
        
          <li>
            <a href="/2022/01/30/2019-03-14-%E5%86%85%E7%94%B0%E5%85%89%E5%AD%90-%E5%85%B3%E4%BA%8E%E4%B8%80%E6%B5%81%E6%B0%B4%E5%87%86%E7%9A%84%E6%80%9D%E8%80%83/">内田光子-关于一流水准的思考</a>
          </li>
        
          <li>
            <a href="/2022/01/30/2019-03-11-%E5%90%B4%E5%86%9B-%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1-%E7%AC%94%E8%AE%B0-01/">读吴军《硅谷来信》心得笔记 - 第一篇</a>
          </li>
        
          <li>
            <a href="/2022/01/30/2019-03-11-2018%E5%B9%B4%E5%A4%A7%E5%85%B4%E5%8C%BA%E5%B9%BC%E5%8D%87%E5%B0%8F%E6%94%BF%E7%AD%96/">2018年大兴区幼升小政策</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>