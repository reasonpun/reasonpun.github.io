<!DOCTYPE html><html lang=""><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content=""/><title>kafka文档简述 | Tensor Cell</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">kafka文档简述</h1><a id="logo" href="/">Tensor Cell</a><p class="description">还要再走500里</p></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">kafka文档简述</h1><div class="post-meta">2015-12-05 | <span class="categories">分类于<a href="/categories/数据挖掘/"> 数据挖掘</a></span></div><span data-disqus-identifier="2015/12/05/kafa-documentation/" class="disqus-comment-count"></span><div class="post-content"><!--  -->
<!--  -->
<!--  _ __    __     __      ____    ___     ___   _____   __  __    ___     -->
<!-- /\`'__\/'__`\ /'__`\   /',__\  / __`\ /' _ `\/\ '__`\/\ \/\ \ /' _ `\   -->
<!-- \ \ \//\  __//\ \L\.\_/\__, `\/\ \L\ \/\ \/\ \ \ \L\ \ \ \_\ \/\ \/\ \  -->
<!--  \ \_\\ \____\ \__/.\_\/\____/\ \____/\ \_\ \_\ \ ,__/\ \____/\ \_\ \_\ -->
<!--   \/_/ \/____/\/__/\/_/\/___/  \/___/  \/_/\/_/\ \ \/  \/___/  \/_/\/_/ -->
<!--                                                 \ \_\                   -->
<!--                                                  \/_/                   -->
<!--  -->
<h3 id="u7FFB_u8BD1ing"><a href="#u7FFB_u8BD1ing" class="headerlink" title="翻译ing"></a>翻译ing</h3><h2 id="u672F_u8BED_u8868"><a href="#u672F_u8BED_u8868" class="headerlink" title="术语表"></a>术语表</h2><table>
<thead>
<tr>
<th>名词术语</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>topic</td>
<td>主题</td>
</tr>
<tr>
<td>producer</td>
<td>生产者</td>
</tr>
<tr>
<td>comsumer</td>
<td>消费者</td>
</tr>
<tr>
<td>broker</td>
<td>代理</td>
</tr>
<tr>
<td>partition</td>
<td>分区</td>
</tr>
<tr>
<td>offset</td>
<td>下标</td>
</tr>
<tr>
<td>round-robin</td>
<td>轮询</td>
</tr>
<tr>
<td>key</td>
<td>键</td>
</tr>
<tr>
<td>queuing</td>
<td>排队</td>
</tr>
<tr>
<td>publish-subscribe</td>
<td>发布-订阅</td>
</tr>
<tr>
<td>the consumer group</td>
<td>消费者组</td>
</tr>
<tr>
<td>subscriber</td>
<td>订阅者</td>
</tr>
<tr>
<td>guarantee</td>
<td>保证（?）</td>
</tr>
</tbody>
</table>
<h2 id="Kafka_0-9-0__u6587_u6863"><a href="#Kafka_0-9-0__u6587_u6863" class="headerlink" title="Kafka 0.9.0 文档"></a>Kafka 0.9.0 文档</h2><ol>
<li>开始<ul>
<li>1.1 简介</li>
<li>1.2 用例</li>
<li>1.3 快速入门</li>
<li>1.4 生态圈</li>
<li>1.5 升级</li>
</ul>
</li>
<li>API<ul>
<li>2.1 生产者 API</li>
<li>2.2 消费者 API<ul>
<li>2.2.1 Old High Level Consumer API</li>
<li>2.2.2 Old Simple Consumer API</li>
<li>2.2.3 New Consumer API</li>
</ul>
</li>
</ul>
</li>
<li>配置<ul>
<li>3.1 代理配置</li>
<li>3.2 生产者配置</li>
<li>3.3 消费者配置<ul>
<li>3.3.1 Old Consumer Configs</li>
<li>3.3.2 New Consumer Configs</li>
<li>3.4 Kafka 连接配置</li>
</ul>
</li>
</ul>
</li>
<li>设计<ul>
<li>4.1 Motivation</li>
<li>4.2 持久化</li>
<li>4.3 Efficiency</li>
<li>4.4 生产者</li>
<li>4.5 消费者</li>
<li>4.6 Message Delivery Semantics</li>
<li>4.7 Replication</li>
<li>4.8 Log Compaction</li>
<li>4.9 Quotas</li>
</ul>
</li>
<li>实现<ul>
<li>5.1 API 设计</li>
<li>5.2 网络层</li>
<li>5.3 消息</li>
<li>5.4 消息格式</li>
<li>5.5 日志</li>
<li>5.6 分布式</li>
</ul>
</li>
<li>Operations<ul>
<li>6.1 Basic Kafka Operations<ul>
<li>Adding and removing topics</li>
<li>Modifying topics</li>
<li>Graceful shutdown</li>
<li>Balancing leadership</li>
<li>Checking consumer position</li>
<li>Mirroring data between clusters</li>
<li>Expanding your cluster</li>
<li>Decommissioning brokers</li>
<li>Increasing replication factor</li>
</ul>
</li>
<li>6.2 Datacenters</li>
<li>6.3 Important Configs<ul>
<li>Important Server Configs</li>
<li>Important Client Configs</li>
<li>A Production Server Configs</li>
</ul>
</li>
<li>6.4 Java Version</li>
<li>6.5 Hardware and OS<ul>
<li>OS</li>
<li>Disks and Filesystems</li>
<li>Application vs OS Flush Management</li>
<li>Linux Flush Behavior</li>
<li>Ext4 Notes</li>
</ul>
</li>
<li>6.6 Monitoring</li>
<li>6.7 ZooKeeper<ul>
<li>Stable Version</li>
<li>Operationalization</li>
</ul>
</li>
</ul>
</li>
<li>安全性<ul>
<li>7.1 Security Overview</li>
<li>7.2 Encryption and Authentication using SSL</li>
<li>7.3 Authentication using SASL</li>
<li>7.4 Authorization and ACLs</li>
<li>7.5 ZooKeeper Authentication<ul>
<li>New Clusters</li>
<li>Migrating Clusters</li>
<li>Migrating the ZooKeeper Ensemble</li>
</ul>
</li>
</ul>
</li>
<li>Kafka Connect<ul>
<li>8.1 Overview</li>
<li>8.2 User Guide</li>
<li>8.3 Connector Development Guide</li>
</ul>
</li>
</ol>
<h2 id="1-__u5F00_u59CB"><a href="#1-__u5F00_u59CB" class="headerlink" title="1. 开始"></a>1. 开始</h2><h3 id="1-1__u7B80_u4ECB"><a href="#1-1__u7B80_u4ECB" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>kafka是一个分布式的，分区的，复用的日志提交服务。它以一种独特的设计方式提供消息传递系统的功能。</p>
<p>这是什么意思呢？</p>
<p>First let’s review some basic messaging terminology:</p>
<ul>
<li>Kafka maintains feeds of messages in categories called topics.</li>
<li>We’ll call processes that publish messages to a Kafka topic producers.</li>
<li>We’ll call processes that subscribe to topics and process the feed of published messages consumers..</li>
<li>Kafka is run as a cluster comprised of one or more servers each of which is called a broker.</li>
</ul>
<p>So, at a high level, producers send messages over the network to the Kafka cluster which in turn serves them up to consumers like this:</p>
<img src="/images/kafka.0.9.0/producer_consumer.png" width="258" height="180" title="生产者消费者关系">
<p>Communication between the clients and the servers is done with a simple, high-performance, language agnostic TCP protocol. We provide a Java client for Kafka, but clients are available in many languages.</p>
<p>服务器端和客户端的通讯是通过一个简单的，高效的，TCP协议无关的语言实现的。不仅提供了Java客户端，还提供了其他很多语言的支持。</p>
<h4 id="Topics_and_Logs"><a href="#Topics_and_Logs" class="headerlink" title="Topics and Logs"></a>Topics and Logs</h4><p>Let’s first dive into the high-level abstraction Kafka provides—the topic.<br>A topic is a category or feed name to which messages are published. For each topic, the Kafka cluster maintains a partitioned log that looks like this:</p>
<img src="/images/kafka.0.9.0/producer_consumer.png" width="258" height="180" title="生产者消费者关系">
<p>Each partition is an ordered, immutable sequence of messages that is continually appended to—a commit log. The messages in the partitions are each assigned a sequential id number called the offset that uniquely identifies each message within the partition.<br>The Kafka cluster retains all published messages—whether or not they have been consumed—for a configurable period of time. For example if the log retention is set to two days, then for the two days after a message is published it is available for consumption, after which it will be discarded to free up space. Kafka’s performance is effectively constant with respect to data size so retaining lots of data is not a problem.</p>
<p>In fact the only metadata retained on a per-consumer basis is the position of the consumer in the log, called the “offset”. This offset is controlled by the consumer: normally a consumer will advance its offset linearly as it reads messages, but in fact the position is controlled by the consumer and it can consume messages in any order it likes. For example a consumer can reset to an older offset to reprocess.</p>
<p>This combination of features means that Kafka consumers are very cheap—they can come and go without much impact on the cluster or on other consumers. For example, you can use our command line tools to “tail” the contents of any topic without changing what is consumed by any existing consumers.</p>
<p>The partitions in the log serve several purposes. First, they allow the log to scale beyond a size that will fit on a single server. Each individual partition must fit on the servers that host it, but a topic may have many partitions so it can handle an arbitrary amount of data. Second they act as the unit of parallelism—more on that in a bit.</p>
<h4 id="Distribution"><a href="#Distribution" class="headerlink" title="Distribution"></a>Distribution</h4><p>The partitions of the log are distributed over the servers in the Kafka cluster with each server handling data and requests for a share of the partitions. Each partition is replicated across a configurable number of servers for fault tolerance.<br>Each partition has one server which acts as the “leader” and zero or more servers which act as “followers”. The leader handles all read and write requests for the partition while the followers passively replicate the leader. If the leader fails, one of the followers will automatically become the new leader. Each server acts as a leader for some of its partitions and a follower for others so load is well balanced within the cluster.</p>
<h4 id="Producers"><a href="#Producers" class="headerlink" title="Producers"></a>Producers</h4><p>Producers publish data to the topics of their choice. The producer is responsible for choosing which message to assign to which partition within the topic. This can be done in a round-robin fashion simply to balance load or it can be done according to some semantic partition function (say based on some key in the message). More on the use of partitioning in a second.</p>
<h4 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h4><p>Messaging traditionally has two models: queuing and publish-subscribe. In a queue, a pool of consumers may read from a server and each message goes to one of them; in publish-subscribe the message is broadcast to all consumers. Kafka offers a single consumer abstraction that generalizes both of these—the consumer group.<br>Consumers label themselves with a consumer group name, and each message published to a topic is delivered to one consumer instance within each subscribing consumer group. Consumer instances can be in separate processes or on separate machines.</p>
<p>If all the consumer instances have the same consumer group, then this works just like a traditional queue balancing load over the consumers.</p>
<p>If all the consumer instances have different consumer groups, then this works like publish-subscribe and all messages are broadcast to all consumers.</p>
<p>More commonly, however, we have found that topics have a small number of consumer groups, one for each “logical subscriber”. Each group is composed of many consumer instances for scalability and fault tolerance. This is nothing more than publish-subscribe semantics where the subscriber is cluster of consumers instead of a single process.</p>
<p>Kafka has stronger ordering guarantees than a tranditional messageing system, too.</p>
<img src="/images/kafka.0.9.0/kafka_cluster.png" title="kafka_cluster">
<p>A traditional queue retains messages in-order on the server, and if multiple consumers consume from the queue then the server hands out messages in the order they are stored. However, although the server hands out messages in order, the messages are delivered asynchronously to consumers, so they may arrive out of order on different consumers. This effectively means the ordering of the messages is lost in the presence of parallel consumption. Messaging systems often work around this by having a notion of “exclusive consumer” that allows only one process to consume from a queue, but of course this means that there is no parallelism in processing.</p>
<p>Kafka does it better. By having a notion of parallelism—the partition—within the topics, Kafka is able to provide both ordering guarantees and load balancing over a pool of consumer processes. This is achieved by assigning the partitions in the topic to the consumers in the consumer group so that each partition is consumed by exactly one consumer in the group. By doing this we ensure that the consumer is the only reader of that partition and consumes the data in order. Since there are many partitions this still balances the load over many consumer instances. Note however that there cannot be more consumer instances in a consumer group than partitions.</p>
<p>Kafka only provides a total order over messages within a partition, not between different partitions in a topic. Per-partition ordering combined with the ability to partition data by key is sufficient for most applications. However, if you require a total order over messages this can be achieved with a topic that has only one partition, though this will mean only one consumer process per consumer group.</p>
<h4 id="Guarantees"><a href="#Guarantees" class="headerlink" title="Guarantees"></a>Guarantees</h4><p>At a high-level Kafka gives the following guarantees:</p>
<ul>
<li>Messages sent by a producer to a particular topic partition will be appended in the order they are sent. That is, if a message M1 is sent by the same producer as a message M2, and M1 is sent first, then M1 will have a lower offset than M2 and appear earlier in the log.</li>
<li>A consumer instance sees messages in the order they are stored in the log.</li>
<li>For a topic with replication factor N, we will tolerate up to N-1 server failures without losing any messages committed to the log.<br>More details on these guarantees are given in the design section of the documentation.</li>
</ul>
<h3 id="1-2_Use_Cases"><a href="#1-2_Use_Cases" class="headerlink" title="1.2 Use Cases"></a>1.2 Use Cases</h3><p>Here is a description of a few of the popular use cases for Apache Kafka. For an overview of a number of these areas in action, see this blog post.</p>
<h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><p>Kafka works well as a replacement for a more traditional message broker. Message brokers are used for a variety of reasons (to decouple processing from data producers, to buffer unprocessed messages, etc). In comparison to most messaging systems Kafka has better throughput, built-in partitioning, replication, and fault-tolerance which makes it a good solution for large scale message processing applications.<br>In our experience messaging uses are often comparatively low-throughput, but may require low end-to-end latency and often depend on the strong durability guarantees Kafka provides.</p>
<p>In this domain Kafka is comparable to traditional messaging systems such as ActiveMQ or RabbitMQ.</p>
<h4 id="Website_Activity_Tracking"><a href="#Website_Activity_Tracking" class="headerlink" title="Website Activity Tracking"></a>Website Activity Tracking</h4><p>The original use case for Kafka was to be able to rebuild a user activity tracking pipeline as a set of real-time publish-subscribe feeds. This means site activity (page views, searches, or other actions users may take) is published to central topics with one topic per activity type. These feeds are available for subscription for a range of use cases including real-time processing, real-time monitoring, and loading into Hadoop or offline data warehousing systems for offline processing and reporting.<br>Activity tracking is often very high volume as many activity messages are generated for each user page view.</p>
<h4 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h4><p>Kafka is often used for operational monitoring data. This involves aggregating statistics from distributed applications to produce centralized feeds of operational data.</p>
<h4 id="Log_Aggregation"><a href="#Log_Aggregation" class="headerlink" title="Log Aggregation"></a>Log Aggregation</h4><p>Many people use Kafka as a replacement for a log aggregation solution. Log aggregation typically collects physical log files off servers and puts them in a central place (a file server or HDFS perhaps) for processing. Kafka abstracts away the details of files and gives a cleaner abstraction of log or event data as a stream of messages. This allows for lower-latency processing and easier support for multiple data sources and distributed data consumption. In comparison to log-centric systems like Scribe or Flume, Kafka offers equally good performance, stronger durability guarantees due to replication, and much lower end-to-end latency.</p>
<h4 id="Stream_Processing"><a href="#Stream_Processing" class="headerlink" title="Stream Processing"></a>Stream Processing</h4><p>Many users end up doing stage-wise processing of data where data is consumed from topics of raw data and then aggregated, enriched, or otherwise transformed into new Kafka topics for further consumption. For example a processing flow for article recommendation might crawl article content from RSS feeds and publish it to an “articles” topic; further processing might help normalize or deduplicate this content to a topic of cleaned article content; a final stage might attempt to match this content to users. This creates a graph of real-time data flow out of the individual topics. Storm and Samza are popular frameworks for implementing these kinds of transformations.</p>
<h4 id="Event_Sourcing"><a href="#Event_Sourcing" class="headerlink" title="Event Sourcing"></a>Event Sourcing</h4><p>Event sourcing is a style of application design where state changes are logged as a time-ordered sequence of records. Kafka’s support for very large stored log data makes it an excellent backend for an application built in this style.</p>
<h4 id="Commit_Log"><a href="#Commit_Log" class="headerlink" title="Commit Log"></a>Commit Log</h4><p>Kafka can serve as a kind of external commit-log for a distributed system. The log helps replicate data between nodes and acts as a re-syncing mechanism for failed nodes to restore their data. The log compaction feature in Kafka helps support this usage. In this usage Kafka is similar to Apache BookKeeper project.</p>
<h3 id="1-3_Quick_Start"><a href="#1-3_Quick_Start" class="headerlink" title="1.3 Quick Start"></a>1.3 Quick Start</h3><p>This tutorial assumes you are starting fresh and have no existing Kafka or ZooKeeper data.</p>
<h4 id="Step_1_3A_Download_the_code"><a href="#Step_1_3A_Download_the_code" class="headerlink" title="Step 1: Download the code"></a>Step 1: Download the code</h4><p>Download the 0.9.0.0 release and un-tar it.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">tar</span> <span class="tag">-xzf</span> <span class="tag">kafka_2</span><span class="class">.11-0</span><span class="class">.9</span><span class="class">.0</span><span class="class">.0</span><span class="class">.tgz</span></span><br><span class="line">&gt; <span class="tag">cd</span> <span class="tag">kafka_2</span><span class="class">.11-0</span><span class="class">.9</span><span class="class">.0</span><span class="class">.0</span></span><br></pre></td></tr></table></figure>
<h4 id="Step_2_3A_Start_the_server"><a href="#Step_2_3A_Start_the_server" class="headerlink" title="Step 2: Start the server"></a>Step 2: Start the server</h4><p>Kafka uses ZooKeeper so you need to first start a ZooKeeper server if you don’t already have one. You can use the convenience script packaged with kafka to get a quick-and-dirty single-node ZooKeeper instance.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/zookeeper-server-start<span class="class">.sh</span> config/zookeeper<span class="class">.properties</span></span><br><span class="line">[<span class="number">2013</span>-<span class="number">04</span>-<span class="number">22</span> <span class="number">15</span>:<span class="number">01</span>:<span class="number">37</span>,<span class="number">495</span>] INFO Reading configuration from: config/zookeeper<span class="class">.properties</span> (org<span class="class">.apache</span><span class="class">.zookeeper</span><span class="class">.server</span><span class="class">.quorum</span><span class="class">.QuorumPeerConfig</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="Step_3_3A_Create_a_topic"><a href="#Step_3_3A_Create_a_topic" class="headerlink" title="Step 3: Create a topic"></a>Step 3: Create a topic</h4><p>Let’s create a topic named “test” with a single partition and only one replica:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">test</span></span><br></pre></td></tr></table></figure>
<p>We can now see that topic if we run the list topic command:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh <span class="comment">--list --zookeeper localhost:2181</span></span><br><span class="line">test</span><br><span class="line">Alternatively, instead <span class="operator">of</span> manually creating topics you can also configure your brokers <span class="built_in">to</span> auto-<span class="built_in">create</span> topics when <span class="operator">a</span> non-existent topic is published <span class="built_in">to</span>.</span><br></pre></td></tr></table></figure>
<h4 id="Step_4_3A_Send_some_messages"><a href="#Step_4_3A_Send_some_messages" class="headerlink" title="Step 4: Send some messages"></a>Step 4: Send some messages</h4><p>Kafka comes with a command line client that will take input from a file or from standard input and send it out as messages to the Kafka cluster. By default each line will be sent as a separate message.<br>Run the producer and then type a few messages into the console to send to the server.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-console-producer.<span class="keyword">sh</span> --broker-<span class="keyword">list</span> localhos<span class="variable">t:9092</span> --topic test</span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">a</span> message</span><br><span class="line">This <span class="keyword">is</span> another message</span><br></pre></td></tr></table></figure>
<h4 id="Step_5_3A_Start_a_consumer"><a href="#Step_5_3A_Start_a_consumer" class="headerlink" title="Step 5: Start a consumer"></a>Step 5: Start a consumer</h4><p>Kafka also has a command line consumer that will dump out messages to standard output.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-console-consumer.sh <span class="comment">--zookeeper localhost:2181 --topic test --from-beginning</span></span><br><span class="line">This is <span class="operator">a</span> message</span><br><span class="line">This is another message</span><br><span class="line">If you have <span class="keyword">each</span> <span class="operator">of</span> <span class="operator">the</span> above commands running <span class="operator">in</span> <span class="operator">a</span> different terminal <span class="keyword">then</span> you should now be able <span class="built_in">to</span> type messages <span class="keyword">into</span> <span class="operator">the</span> producer terminal <span class="operator">and</span> see them appear <span class="operator">in</span> <span class="operator">the</span> consumer terminal.</span><br></pre></td></tr></table></figure>
<p>All of the command line tools have additional options; running the command with no arguments will display usage information documenting them in more detail.</p>
<h4 id="Step_6_3A_Setting_up_a_multi-broker_cluster"><a href="#Step_6_3A_Setting_up_a_multi-broker_cluster" class="headerlink" title="Step 6: Setting up a multi-broker cluster"></a>Step 6: Setting up a multi-broker cluster</h4><p>So far we have been running against a single broker, but that’s no fun. For Kafka, a single broker is just a cluster of size one, so nothing much changes other than starting a few more broker instances. But just to get feel for it, let’s expand our cluster to three nodes (still all on our local machine).<br>First we make a config file for each of the brokers:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cp config/server<span class="class">.properties</span> config/server-<span class="number">1</span><span class="class">.properties</span></span><br><span class="line">&gt; cp config/server<span class="class">.properties</span> config/server-<span class="number">2</span>.properties</span><br></pre></td></tr></table></figure>
<p>Now edit these new files and set the following properties:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config/server-<span class="number">1.</span>properties:</span><br><span class="line">    broker.id=<span class="number">1</span></span><br><span class="line">    port=<span class="number">9093</span></span><br><span class="line">    <span class="built_in">log</span>.dir=/tmp/kafka-logs-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">config/server-<span class="number">2.</span>properties:</span><br><span class="line">    broker.id=<span class="number">2</span></span><br><span class="line">    port=<span class="number">9094</span></span><br><span class="line">    <span class="built_in">log</span>.dir=/tmp/kafka-logs-<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>The broker.id property is the unique and permanent name of each node in the cluster. We have to override the port and log directory only because we are running these all on the same machine and we want to keep the brokers from all trying to register on the same port or overwrite each others data.</p>
<p>We already have Zookeeper and our single node started, so we just need to start the two new nodes:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-server-start<span class="class">.sh</span> config/server-<span class="number">1</span><span class="class">.properties</span> &amp;</span><br><span class="line">...</span><br><span class="line">&gt; bin/kafka-server-start<span class="class">.sh</span> config/server-<span class="number">2</span><span class="class">.properties</span> &amp;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Now create a new topic with a replication factor of three:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">3</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">my</span><span class="literal">-</span><span class="comment">replicated</span><span class="literal">-</span><span class="comment">topic</span></span><br></pre></td></tr></table></figure>
<p>Okay but now that we have a cluster how can we know which broker is doing what? To see that run the “describe topics” command:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">describe</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">my</span><span class="literal">-</span><span class="comment">replicated</span><span class="literal">-</span><span class="comment">topic</span></span><br></pre></td></tr></table></figure>
<p>Topic:my-replicated-topic    PartitionCount:1    ReplicationFactor:3    Configs:</p>
<pre><code>Topic: my-replicated-topic    Partition: 0    Leader: 1    Replicas: 1,2,0    Isr: 1,2,0
</code></pre><p>Here is an explanation of output. The first line gives a summary of all the partitions, each additional line gives information about one partition. Since we have only one partition for this topic there is only one line.</p>
<ul>
<li>“leader” is the node responsible for all reads and writes for the given partition. Each node will be the leader for a randomly selected portion of the partitions.</li>
<li>“replicas” is the list of nodes that replicate the log for this partition regardless of whether they are the leader or even if they are currently alive.</li>
<li>“isr” is the set of “in-sync” replicas. This is the subset of the replicas list that is currently alive and caught-up to the leader.</li>
</ul>
<p>Note that in my example node 1 is the leader for the only partition of the topic.</p>
<p>We can run the same command on the original topic we created to see where it is:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper <span class="string">localhost:</span><span class="number">2181</span> --topic test</span><br><span class="line"><span class="label"></span><br><span class="line">Topic:</span>test	<span class="string">PartitionCount:</span><span class="number">1</span>	<span class="string">ReplicationFactor:</span><span class="number">1</span>	<span class="string">Configs:</span></span><br><span class="line"><span class="label">	Topic:</span> test	<span class="string">Partition:</span> <span class="number">0</span>	<span class="string">Leader:</span> <span class="number">0</span>	<span class="string">Replicas:</span> <span class="number">0</span>	<span class="string">Isr:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>So there is no surprise there—the original topic has no replicas and is on server 0, the only server in our cluster when we created it.</p>
<p>Let’s publish a few messages to our new topic:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-console-producer.sh --broker-<span class="built_in">list</span> localhost:<span class="number">9092</span> --topic my-replicated-topic</span><br><span class="line">...</span><br><span class="line">my test message <span class="number">1</span></span><br><span class="line">my test message <span class="number">2</span></span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<p>Now let’s consume these messages:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-console-consumer.sh <span class="comment">--zookeeper localhost:2181 --from-beginning --topic my-replicated-topic</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">my</span> test message <span class="number">1</span></span><br><span class="line"><span class="keyword">my</span> test message <span class="number">2</span></span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<p>Now let’s test out fault-tolerance. Broker 1 was acting as the leader so let’s kill it:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps | grep server-<span class="number">1.</span>properties</span><br><span class="line"><span class="number">7564</span> ttys002    <span class="number">0</span>:<span class="number">15.91</span> /System/Library/Frameworks/JavaVM.framework/Versions/<span class="number">1.6</span>/Home/bin/java...</span><br><span class="line">&gt; kill -<span class="number">9</span> <span class="number">7564</span></span><br></pre></td></tr></table></figure>
<p>Leadership has switched to one of the slaves and node 1 is no longer in the in-sync replica set:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics.sh --describe --zookeeper localhost:<span class="number">2181</span> --topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topic	PartitionCount:<span class="number">1</span>	ReplicationFactor:<span class="number">3</span>	Configs:</span><br><span class="line">	Topic: my-replicated-topic	Partition: <span class="number">0</span>	Leader: <span class="number">2</span>	Replicas: <span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>	Isr: <span class="number">2</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>But the messages are still be available for consumption even though the leader that took the writes originally is down:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-console-consumer.sh <span class="comment">--zookeeper localhost:2181 --from-beginning --topic my-replicated-topic</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">my</span> test message <span class="number">1</span></span><br><span class="line"><span class="keyword">my</span> test message <span class="number">2</span></span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<h4 id="Step_7_3A_Use_Kafka_Connect_to_import/export_data"><a href="#Step_7_3A_Use_Kafka_Connect_to_import/export_data" class="headerlink" title="Step 7: Use Kafka Connect to import/export data"></a>Step 7: Use Kafka Connect to import/export data</h4><p>Writing data from the console and writing it back to the console is a convenient place to start, but you’ll probably want to use data from other sources or export data from Kafka to other systems. For many systems, instead of writing custom integration code you can use Kafka Connect to import or export data. Kafka Connect is a tool included with Kafka that imports and exports data to Kafka. It is an extensible tool that runs connectors, which implement the custom logic for interacting with an external system. In this quickstart we’ll see how to run Kafka Connect with simple connectors that import data from a file to a Kafka topic and export data from a Kafka topic to a file. First, we’ll start by creating some seed data to test with:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"foo\nbar"</span> &gt; test.txt</span><br></pre></td></tr></table></figure>
<p>Next, we’ll start two connectors running in standalone mode, which means they run in a single, local, dedicated process. We provide three configuration files as parameters. The first is always the configuration for the Kafka Connect process, containing common configuration such as the Kafka brokers to connect to and the serialization format for data. The remaining configuration files each specify a connector to create. These files include a unique connector name, the connector class to instantiate, and any other configuration required by the connector.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/connect-standalone<span class="class">.sh</span> config/connect-standalone<span class="class">.properties</span> config/connect-file-source<span class="class">.properties</span> config/connect-file-sink.properties</span><br></pre></td></tr></table></figure>
<p>These sample configuration files, included with Kafka, use the default local cluster configuration you started earlier and create two connectors: the first is a source connector that reads lines from an input file and produces each to a Kafka topic and the second is a sink connector that reads messages from a Kafka topic and produces each as a line in an output file. During startup you’ll see a number of log messages, including some indicating that the connectors are being instantiated. Once the Kafka Connect process has started, the source connector should start reading lines from</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">test</span><span class="class">.txt</span></span><br></pre></td></tr></table></figure>
<p>and producing them to the topic</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">connect</span>-test</span><br></pre></td></tr></table></figure>
<p>, and the sink connector should start reading messages from the topic</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">connect</span>-test</span><br></pre></td></tr></table></figure>
<p>and write them to the file</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test<span class="class">.sink</span><span class="class">.txt</span></span><br></pre></td></tr></table></figure>
<p>. We can verify the data has been delivered through the entire pipeline by examining the contents of the output file:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat test<span class="class">.sink</span><span class="class">.txt</span></span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>Note that the data is being stored in the Kafka topic</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">connect</span>-test</span><br></pre></td></tr></table></figure>
<p>, so we can also run a console consumer to see the data in the topic (or use custom consumer code to process it):</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-<span class="built_in">console</span>-consumer.sh --zookeeper <span class="attribute">localhost</span>:<span class="number">2181</span> --topic connect-test --<span class="keyword">from</span>-beginning</span><br><span class="line">&#123;<span class="string">"schema"</span>:&#123;<span class="string">"type"</span>:<span class="string">"string"</span>,<span class="string">"optional"</span>:<span class="literal">false</span>&#125;,<span class="string">"payload"</span>:<span class="string">"foo"</span>&#125;</span><br><span class="line">&#123;<span class="string">"schema"</span>:&#123;<span class="string">"type"</span>:<span class="string">"string"</span>,<span class="string">"optional"</span>:<span class="literal">false</span>&#125;,<span class="string">"payload"</span>:<span class="string">"bar"</span>&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The connectors continue to process data, so we can add data to the file and see it move through the pipeline:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; echo <span class="string">"Another line"</span> <span class="prompt">&gt;&gt; </span>test.txt</span><br></pre></td></tr></table></figure>
<p>You should see the line appear in the console consumer output and in the sink file.</p>
<h3 id="1-4_Ecosystem"><a href="#1-4_Ecosystem" class="headerlink" title="1.4 Ecosystem"></a>1.4 Ecosystem</h3><p>There are a plethora of tools that integrate with Kafka outside the main distribution. The ecosystem page lists many of these, including stream processing systems, Hadoop integration, monitoring, and deployment tools.</p>
<h2 id="2-_API"><a href="#2-_API" class="headerlink" title="2. API"></a>2. API</h2><p>Apache Kafka includes new java clients (in the org.apache.kafka.clients package). These are meant to supplant the older Scala clients, but for compatability they will co-exist for some time. These clients are available in a seperate jar with minimal dependencies, while the old Scala clients remain packaged with the server.</p>
<h3 id="2-1_Producer_API"><a href="#2-1_Producer_API" class="headerlink" title="2.1 Producer API"></a>2.1 Producer API</h3><p>We encourage all new development to use the new Java producer. This client is production tested and generally both faster and more fully featured than the previous Scala client. You can use this client by adding a dependency on the client jar using the following example maven co-ordinates (you can change the version numbers with new releases):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>0.9.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Examples showing how to use the producer are given in the <a href="http://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html" target="_blank" rel="external">javadocs</a>.<br>For those interested in the legacy Scala producer api, information can be found <a href="http://kafka.apache.org/081/documentation.html#producerapi" target="_blank" rel="external">here</a>.</p>
<h3 id="2-2_Consumer_API"><a href="#2-2_Consumer_API" class="headerlink" title="2.2 Consumer API"></a>2.2 Consumer API</h3><p>As of the 0.9.0 release we have added a new Java consumer to replace our existing high-level ZooKeeper-based consumer and low-level consumer APIs. This client is considered beta quality. To ensure a smooth upgrade paths for users, we still maintain the old 0.8 consumer clients that continue to work on an 0.9 Kafka cluster. In the following sections we introduce both the old 0.8 consumer APIs (both high-level ConsumerConnector and low-level SimpleConsumer) and the new Java consumer API respectively.</p>
<h4 id="2-2-1_Old_High_Level_Consumer_API"><a href="#2-2-1_Old_High_Level_Consumer_API" class="headerlink" title="2.2.1 Old High Level Consumer API"></a>2.2.1 Old High Level Consumer API</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Consumer &#123;</span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Create a ConsumerConnector</span><br><span class="line">   <span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param config  at the minimum, need to specify the groupid of the consumer and the zookeeper</span></span><br><span class="line">   <span class="keyword">*</span>                 connection string zookeeper.connect.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public static kafka.javaapi.consumer.ConsumerConnector createJavaConsumerConnector(ConsumerConfig config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span>  V: type of the message</span><br><span class="line"> <span class="keyword">*</span>  K: type of the optional key assciated with the message</span><br><span class="line"> <span class="keyword">*</span>/</span><br><span class="line">public interface kafka.javaapi.consumer.ConsumerConnector &#123;</span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Create a list of message streams of type T for each topic.</span><br><span class="line">   <span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param topicCountMap  a map of (topic, #streams) pair</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param decoder a decoder that converts from Message to T</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@return a map of (topic, list of  KafkaStream) pairs.</span></span><br><span class="line">   <span class="keyword">*</span>          The number of items in the list is <span class="comment">#streams. Each stream supports</span></span><br><span class="line">   <span class="keyword">*</span>          an iterator over message/metadata pairs.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public <span class="variable">&lt;K,V&gt;</span> Map<span class="variable">&lt;String, List&lt;KafkaStream&lt;K,V&gt;</span>&gt;&gt;</span><br><span class="line">    createMessageStreams(Map<span class="variable">&lt;String, Integer&gt;</span> topicCountMap, Decoder<span class="variable">&lt;K&gt;</span> keyDecoder, Decoder<span class="variable">&lt;V&gt;</span> valueDecoder);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Create a list of message streams of type T for each topic, using the default decoder.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public Map<span class="variable">&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;</span>&gt;&gt; createMessageStreams(Map<span class="variable">&lt;String, Integer&gt;</span> topicCountMap);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Create a list of message streams for topics matching a wildcard.</span><br><span class="line">   <span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param topicFilter a TopicFilter that specifies which topics to</span></span><br><span class="line">   <span class="keyword">*</span>                    subscribe to (encapsulates a whitelist or a blacklist).</span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param numStreams the number of message streams to return.</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param keyDecoder a decoder that decodes the message key</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param valueDecoder a decoder that decodes the message itself</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@return a list of KafkaStream. Each stream supports an</span></span><br><span class="line">   <span class="keyword">*</span>          iterator over its MessageAndMetadata elements.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public <span class="variable">&lt;K,V&gt;</span> List<span class="variable">&lt;KafkaStream&lt;K,V&gt;</span>&gt;</span><br><span class="line">    createMessageStreamsByFilter(TopicFilter topicFilter, int numStreams, Decoder<span class="variable">&lt;K&gt;</span> keyDecoder, Decoder<span class="variable">&lt;V&gt;</span> valueDecoder);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Create a list of message streams for topics matching a wildcard, using the default decoder.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public List<span class="variable">&lt;KafkaStream&lt;byte[], byte[]&gt;</span>&gt; createMessageStreamsByFilter(TopicFilter topicFilter, int numStreams);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Create a list of message streams for topics matching a wildcard, using the default decoder, with one stream.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public List<span class="variable">&lt;KafkaStream&lt;byte[], byte[]&gt;</span>&gt; createMessageStreamsByFilter(TopicFilter topicFilter);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Commit the offsets of all topic/partitions connected by this connector.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public void commitOffsets();</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Shut down the connector</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public void shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can follow this <a href="https://cwiki.apache.org/confluence/display/KAFKA/Consumer+Group+Example" target="_blank" rel="external">example</a> to learn how to use the high level consumer api.</p>
<h4 id="2-2-2_Old_Simple_Consumer_API"><a href="#2-2-2_Old_Simple_Consumer_API" class="headerlink" title="2.2.2 Old Simple Consumer API"></a>2.2.2 Old Simple Consumer API</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class kafka.javaapi.consumer.SimpleConsumer &#123;</span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Fetch a set of messages from a topic.</span><br><span class="line">   <span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param request specifies the topic name, topic partition, starting byte offset, maximum bytes to be fetched.</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@return a set of fetched messages</span></span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public FetchResponse fetch(kafka.javaapi.FetchRequest request);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Fetch metadata for a sequence of topics.</span><br><span class="line">   <span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param request specifies the versionId, clientId, sequence of topics.</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@return metadata for each topic in the request.</span></span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public kafka.javaapi.TopicMetadataResponse send(kafka.javaapi.TopicMetadataRequest request);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  Get a list of valid offsets (up to maxSize) before the given time.</span><br><span class="line">   <span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@param request a [[kafka.javaapi.OffsetRequest]] object.</span></span><br><span class="line">   <span class="keyword">*</span>  <span class="comment">@return a [[kafka.javaapi.OffsetResponse]] object.</span></span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public kafka.javaapi.OffsetResponse getOffsetsBefore(OffsetRequest request);</span><br><span class="line"></span><br><span class="line">  /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">   <span class="keyword">*</span> Close the SimpleConsumer.</span><br><span class="line">   <span class="keyword">*</span>/</span><br><span class="line">  public void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For most applications, the high level consumer Api is good enough. Some applications want features not exposed to the high level consumer yet (e.g., set initial offset when restarting the consumer). They can instead use our low level SimpleConsumer Api. The logic will be a bit more complicated and you can follow the example in <a href="https://cwiki.apache.org/confluence/display/KAFKA/0.8.0+SimpleConsumer+Example" target="_blank" rel="external">here</a>.</p>
<h4 id="2-2-3_New_Consumer_API"><a href="#2-2-3_New_Consumer_API" class="headerlink" title="2.2.3 New Consumer API"></a>2.2.3 New Consumer API</h4><p>This new unified consumer API removes the distinction between the 0.8 high-level and low-level consumer APIs. You can use this client by adding a dependency on the client jar using the following example maven co-ordinates (you can change the version numbers with new releases):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>0.9.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Examples showing how to use the consumer are given in the <a href="http://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" target="_blank" rel="external">javadocs</a>.</p>
<h2 id="3-_Configuration"><a href="#3-_Configuration" class="headerlink" title="3. Configuration"></a>3. Configuration</h2><p>Kafka uses key-value pairs in the <a href="http://en.wikipedia.org/wiki/.properties" target="_blank" rel="external">property file format</a> for configuration. These values can be supplied either from a file or programmatically.</p>
<h3 id="3-1_Broker_Configs"><a href="#3-1_Broker_Configs" class="headerlink" title="3.1 Broker Configs"></a>3.1 Broker Configs</h3><p>The essential configurations are the following:</p>
<ul>
<li>broker.id</li>
<li>log.dirs</li>
<li>zookeeper.connect</li>
</ul>
<p>Topic-level configurations and defaults are discussed in more detail</p>
<p>Configurations pertinent to topics have both a global default as well an optional per-topic override. If no per-topic configuration is given the global default is used. The override can be set at topic creation time by giving one or more –config options. This example creates a topic named my-topic with a custom max message size and flush rate:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">bin/kafka</span><span class="literal">-</span><span class="comment">topics</span><span class="string">.</span><span class="comment">sh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zookeeper</span> <span class="comment">localhost:2181</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">topic</span> <span class="comment">my</span><span class="literal">-</span><span class="comment">topic</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">partitions</span> <span class="comment">1</span></span><br><span class="line">        <span class="literal">-</span><span class="literal">-</span><span class="comment">replication</span><span class="literal">-</span><span class="comment">factor</span> <span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">config</span> <span class="comment">max</span><span class="string">.</span><span class="comment">message</span><span class="string">.</span><span class="comment">bytes=64000</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">config</span> <span class="comment">flush</span><span class="string">.</span><span class="comment">messages=1</span></span><br></pre></td></tr></table></figure>
<p>Overrides can also be changed or set later using the alter topic command. This example updates the max message size for my-topic:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics<span class="class">.sh</span> --zookeeper localhost:<span class="number">2181</span> --alter --topic my-topic</span><br><span class="line">    --config max<span class="class">.message</span><span class="class">.bytes</span>=<span class="number">128000</span></span><br></pre></td></tr></table></figure>
<p>To remove an override you can do</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; bin/kafka-topics<span class="class">.sh</span> --zookeeper localhost:<span class="number">2181</span> --alter --topic my-topic</span><br><span class="line">    --deleteConfig max<span class="class">.message</span><span class="class">.bytes</span></span><br></pre></td></tr></table></figure>
<p>The following are the topic-level configurations. The server’s default configuration for this property is given under the Server Default Property heading, setting this default in the server config allows you to change the default given to topics that have no override specified.</p>
<h2 id="4-_Design"><a href="#4-_Design" class="headerlink" title="4. Design"></a>4. Design</h2><h3 id="4-1_Motivation"><a href="#4-1_Motivation" class="headerlink" title="4.1 Motivation"></a>4.1 Motivation</h3><p>We designed Kafka to be able to act as a unified platform for handling all the real-time data feeds a large company might have. To do this we had to think through a fairly broad set of use cases.</p>
<p>It would have to have high-throughput to support high volume event streams such as real-time log aggregation.</p>
<p>It would need to deal gracefully with large data backlogs to be able to support periodic data loads from offline systems.</p>
<p>It also meant the system would have to handle low-latency delivery to handle more traditional messaging use-cases.</p>
<p>We wanted to support partitioned, distributed, real-time processing of these feeds to create new, derived feeds. This motivated our partitioning and consumer model.</p>
<p>Finally in cases where the stream is fed into other data systems for serving we knew the system would have to be able to guarantee fault-tolerance in the presence of machine failures.</p>
<p>Supporting these uses led use to a design with a number of unique elements, more akin to a database log then a traditional messaging system. We will outline some elements of the design in the following sections.</p>
<h3 id="4-2_Persistence"><a href="#4-2_Persistence" class="headerlink" title="4.2 Persistence"></a>4.2 Persistence</h3><p><em>Don’t fear the filesystem!</em></p>
<p>Kafka relies heavily on the filesystem for storing and caching messages. There is a general perception that “disks are slow” which makes people skeptical that a persistent structure can offer competitive performance. In fact disks are both much slower and much faster than people expect depending on how they are used; and a properly designed disk structure can often be as fast as the network.</p>
<p>The key fact about disk performance is that the throughput of hard drives has been diverging from the latency of a disk seek for the last decade. As a result the performance of linear writes on a <a href="http://en.wikipedia.org/wiki/Non-RAID_drive_architectures" target="_blank" rel="external">JBOD</a> configuration with six 7200rpm SATA RAID-5 array is about 600MB/sec but the performance of random writes is only about 100k/sec—a difference of over 6000X. These linear reads and writes are the most predictable of all usage patterns, and are heavily optimized by the operating system. A modern operating system provides read-ahead and write-behind techniques that prefetch data in large block multiples and group smaller logical writes into large physical writes. A further discussion of this issue can be found in this <a href="http://queue.acm.org/detail.cfm?id=1563874" target="_blank" rel="external">ACM Queue article</a>; they actually find that <a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg" target="_blank" rel="external">sequential disk access can in some cases be faster than random memory access</a>!</p>
<p>To compensate for this performance divergence modern operating systems have become increasingly aggressive in their use of main memory for disk caching. A modern OS will happily divert all free memory to disk caching with little performance penalty when the memory is reclaimed. All disk reads and writes will go through this unified cache. This feature cannot easily be turned off without using direct I/O, so even if a process maintains an in-process cache of the data, this data will likely be duplicated in OS pagecache, effectively storing everything twice.</p>
<p>Furthermore we are building on top of the JVM, and anyone who has spent any time with Java memory usage knows two things:</p>
<ol>
<li>The memory overhead of objects is very high, often doubling the size of the data stored (or worse).</li>
<li>Java garbage collection becomes increasingly fiddly and slow as the in-heap data increases.</li>
</ol>
<p>As a result of these factors using the filesystem and relying on pagecache is superior to maintaining an in-memory cache or other structure—we at least double the available cache by having automatic access to all free memory, and likely double again by storing a compact byte structure rather than individual objects. Doing so will result in a cache of up to 28-30GB on a 32GB machine without GC penalties. Furthermore this cache will stay warm even if the service is restarted, whereas the in-process cache will need to be rebuilt in memory (which for a 10GB cache may take 10 minutes) or else it will need to start with a completely cold cache (which likely means terrible initial performance). This also greatly simplifies the code as all logic for maintaining coherency between the cache and filesystem is now in the OS, which tends to do so more efficiently and more correctly than one-off in-process attempts. If your disk usage favors linear reads then read-ahead is effectively pre-populating this cache with useful data on each disk read.</p>
<p>This suggests a design which is very simple: rather than maintain as much as possible in-memory and flush it all out to the filesystem in a panic when we run out of space, we invert that. All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel’s pagecache.</p>
<p>This style of pagecache-centric design is described in an article on the design of Varnish here (along with a healthy dose of arrogance).</p>
<p>Intuitively a persistent queue could be built on simple reads and appends to files as is commonly the case with logging solutions. This structure has the advantage that all operations are O(1) and reads do not block writes or each other. This has obvious performance advantages since the performance is completely decoupled from the data size—one server can now take full advantage of a number of cheap, low-rotational speed 1+TB SATA drives. Though they have poor seek performance, these drives have acceptable performance for large reads and writes and come at 1/3 the price and 3x the capacity.</p>
<p>Having access to virtually unlimited disk space without any performance penalty means that we can provide some features not usually found in a messaging system. For example, in Kafka, instead of attempting to deleting messages as soon as they are consumed, we can retain messages for a relative long period (say a week). This leads to a great deal of flexibility for consumers, as we will describe.</p>
<h2 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/docs2cn/apache-kafka-docs/blob/master/index.md" target="_blank" rel="external">https://github.com/docs2cn/apache-kafka-docs/blob/master/index.md</a></li>
<li><a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">http://kafka.apache.org/documentation.html</a></li>
<li><a href="http://www.cnblogs.com/lzqhss/p/4434901.html" target="_blank" rel="external">http://www.cnblogs.com/lzqhss/p/4434901.html</a></li>
<li><a href="http://gfstart.blog.51cto.com/5081306/1414597" target="_blank" rel="external">http://gfstart.blog.51cto.com/5081306/1414597</a></li>
<li><a href="http://yclod.com/kafka-jie-shao/" target="_blank" rel="external">http://yclod.com/kafka-jie-shao/</a></li>
<li><a href="http://www.oschina.net/translate/kafka-design" target="_blank" rel="external">http://www.oschina.net/translate/kafka-design</a></li>
<li><a href="http://blog.csdn.net/beitiandijun/article/details/40582541" target="_blank" rel="external">http://blog.csdn.net/beitiandijun/article/details/40582541</a></li>
<li><a href="http://www.infoq.com/cn/articles/apache-kafka" target="_blank" rel="external">http://www.infoq.com/cn/articles/apache-kafka</a></li>
<li><a href="http://www.doczj.com/doc/20781790b52acfc788ebc955.html" target="_blank" rel="external">http://www.doczj.com/doc/20781790b52acfc788ebc955.html</a></li>
<li><a href="https://baniuyao.gitbooks.io/kafka-0-8-docs-chinese/content/1.1-introduction.html" target="_blank" rel="external">https://baniuyao.gitbooks.io/kafka-0-8-docs-chinese/content/1.1-introduction.html</a></li>
<li><a href="http://www.infoq.com/cn/articles/kafka-analysis-part-1" target="_blank" rel="external">http://www.infoq.com/cn/articles/kafka-analysis-part-1</a></li>
</ul>
</div><div class="tags"><a href="/tags/Documentation/">Documentation</a><a href="/tags/HDFS/">HDFS</a><a href="/tags/Kafka/">Kafka</a></div><div class="post-nav"><a href="/2015/12/08/apache-kafka-structure/" class="pre"><i class="icon-previous">apache_kafka_structure</i></a><a href="/2015/12/05/linux-shell-获得以前日期/" class="next">linux shell 获得以前日期<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'reasonpun';
var disqus_identifier = '2015/12/05/kafa-documentation/';
var disqus_title = 'kafka文档简述';
var disqus_url = 'http://reasonpun.com/2015/12/05/kafa-documentation/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//reasonpun.disqus.com/count.js" async="async"></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://reasonpun.com"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AWK/">AWK</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/AWK/Linux/">Linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/AWK/Linux/Ebook/">Ebook</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/关键字/">关键字</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/源码/">源码</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/学习/">学习</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/">数据挖掘</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/实时计算/">实时计算</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/实时计算/优化/">优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/实时计算/源码分析/">源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/实时计算/虚拟化/">虚拟化</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统维护/">系统维护</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/系统维护/日志处理/">日志处理</a></li></ul></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Flume-NG/" style="font-size: 15px;">Flume-NG</a> <a href="/tags/正则/" style="font-size: 15px;">正则</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/Source/" style="font-size: 15px;">Source</a> <a href="/tags/Kernel/" style="font-size: 15px;">Kernel</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/HDFS/" style="font-size: 15px;">HDFS</a> <a href="/tags/Logrorate/" style="font-size: 15px;">Logrorate</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Documentation/" style="font-size: 15px;">Documentation</a> <a href="/tags/Apache/" style="font-size: 15px;">Apache</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/awk/" style="font-size: 15px;">awk</a> <a href="/tags/programming/" style="font-size: 15px;">programming</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/优化/" style="font-size: 15px;">优化</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Oryx2/" style="font-size: 15px;">Oryx2</a> <a href="/tags/documentation/" style="font-size: 15px;">documentation</a> <a href="/tags/Admin/" style="font-size: 15px;">Admin</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Spark-Streaming/" style="font-size: 15px;">Spark-Streaming</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Recommendation/" style="font-size: 15px;">Recommendation</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Genetic-Algorithm/" style="font-size: 15px;">Genetic Algorithm</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/04/06/Oryx2-终端用户文档/">Oryx2 终端用户文档</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/Java关键字volatile/">Java关键字volatile</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/OKHttp源码学习过程/">OKHttp源码学习过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/24/正则表达式处理Nginx/">正则表达式处理Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/06/TAPL/">TAPL</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/04/Spark优化/">Spark优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/02/Python关键字-yield/">Python关键字:yield</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/21/Oryx2-Admin-Docs/">Oryx2 管理员文档</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/21/Oryx2-Overview/">Oryx2 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/14/Genetic-Algorithm/">Genetic Algorithm</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//reasonpun.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://people.csail.mit.edu/matei/" title="Matei Zaharia" target="_blank">Matei Zaharia</a><ul></ul><a href="https://github.com/tensorflow/tensorflow" title="tensorflow" target="_blank">tensorflow</a></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">Tensor Cell.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>