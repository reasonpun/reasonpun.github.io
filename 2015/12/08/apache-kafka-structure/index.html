<!DOCTYPE html><html lang=""><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content=""/><title>apache_kafka_structure | Tensor Cell</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">apache_kafka_structure</h1><a id="logo" href="/">Tensor Cell</a><p class="description">还要再走500里</p></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">apache_kafka_structure</h1><div class="post-meta">2015-12-08 | <span class="categories">分类于<a href="/categories/数据挖掘/"> 数据挖掘</a></span></div><span data-disqus-identifier="2015/12/08/apache-kafka-structure/" class="disqus-comment-count"></span><div class="post-content"><!--  -->
<!--  -->
<!--  _ __    __     __      ____    ___     ___   _____   __  __    ___     -->
<!-- /\`'__\/'__`\ /'__`\   /',__\  / __`\ /' _ `\/\ '__`\/\ \/\ \ /' _ `\   -->
<!-- \ \ \//\  __//\ \L\.\_/\__, `\/\ \L\ \/\ \/\ \ \ \L\ \ \ \_\ \/\ \/\ \  -->
<!--  \ \_\\ \____\ \__/.\_\/\____/\ \____/\ \_\ \_\ \ ,__/\ \____/\ \_\ \_\ -->
<!--   \/_/ \/____/\/__/\/_/\/___/  \/___/  \/_/\/_/\ \ \/  \/___/  \/_/\/_/ -->
<!--                                                 \ \_\                   -->
<!--                                                  \/_/                   -->
<!--  -->
<h4 id="Apache_Kafka_u6D88_u606F_u670D_u52A1"><a href="#Apache_Kafka_u6D88_u606F_u670D_u52A1" class="headerlink" title="Apache Kafka消息服务"></a>Apache Kafka消息服务</h4><ul>
<li><p>参考地址 <a href="http://kafka.apache.org/documentation.html#brokerconfigs" target="_blank" rel="external">http://kafka.apache.org/documentation.html</a></p>
</li>
<li><p>消息队列的分类</p>
<ul>
<li><p>点对点</p>
<p>生产者生产消息发送到Queue中，消费者消费Queue中的消息，其中：</p>
<ul>
<li>Queue中不再存储已经被消费的消息</li>
<li>Queue支持多个消费者，但是同一个消息，只能被一个消费者消费</li>
</ul>
</li>
<li><p>发布/订阅</p>
<p>生产者（生产）将消息发布到topic中，同时多个消费者（消费）订阅该消息。和点对点方式不同的是，发布到topic的消息会被所有订阅者消费</p>
</li>
</ul>
</li>
<li><p>简介</p>
<p>背景 Kafka使用Scala语言编写，是一个分布式，分区的，支持多副本，多订阅者的日志系统。</p>
<p>目前支持Java，Python，C++， PHP等</p>
<ul>
<li>总体结构</li>
</ul>
<img src="/images/kafka.0.9.0/structure.png" title="kafka总体结构图">
</li>
</ul>
<ul>
<li><p>名词解释</p>
<ul>
<li><p>Producer</p>
<p>  消息生产者，就是向kafka broker发消息的客户端</p>
</li>
<li><p>Consumer</p>
<p>  消息消费者，向kafka broker取消息的客户端</p>
</li>
<li><p>Topic</p>
<p>  是一个消息队列？</p>
</li>
<li><p>Consumer Group （CG）</p>
<ul>
<li>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给任意一个Consumer）的手段</li>
<li>一个Topic可以有多个CG</li>
<li>Topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个consumer</li>
<li>如果需要实现广播，只要每个Consumer有一个独立的CG就可以了</li>
<li>要实现单播只要所有的Consumer在同一个CG</li>
<li><p>用CG还可以将Consumer进行自由的分组而不需要多次发送消息到不同的topic</p>
</li>
<li><p>Broker</p>
<ul>
<li>一台Kafka服务器就是一个Broker</li>
<li>一个集群由多个Broker组成。一个Broker可以容纳多个Topic</li>
</ul>
</li>
<li><p>Partition</p>
<p>为了实现扩展性，一个非常大的Topic可以分布到多个Broker（即服务器）上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列。Prtition中的每条消息都会被分配一个有序的id（Offset）。Kafka只保证按一个Partition中的顺序将消息发给Consumer，不保证一个Topic的整体（多个Partition间）的顺序。</p>
</li>
<li><p>Offset</p>
<ul>
<li>kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找</li>
<li>例如你想找位于2049的位置，只要找到2048.kafka的文件即可，当然the first offset就是00000000000.kafka</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能</li>
<li>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数十万的消息</li>
<li>支持 <em>同步</em> 和 <em>异步</em> 复制两种HA</li>
<li>Consumer客户端<ul>
<li>pull</li>
<li>随机读</li>
<li>利用sendfile系统调用</li>
<li>zero-copy</li>
<li>批量拉数据</li>
</ul>
</li>
<li>消费状态保存在客户端</li>
<li>消息存储顺序写</li>
<li>数据迁移、扩容对用户透明</li>
<li>支持Hadoop并行数据加载</li>
<li>支持online和offline的场景</li>
<li>持久化：通过将数据持久化到硬盘以及replication防止数据丢失</li>
<li>scale out：无需停机即可扩展机器</li>
<li>定期删除机制，支持设定partitions的segment file保留时间</li>
</ul>
</li>
<li><p>可靠性（一致性)</p>
<p>传统的MQ系统通常都是通过broker和consumer间的确认（ack）机制实现的，并在broker保存消息分发的状态，即使这样一致性也是很难保证的。</p>
<p>Kafka的做法是由consumer自己保存状态，也不要任何确认。这样虽然consumer负担更重，但其实更灵活了。因为不管consumer上任何原因导致需要重新处理消息，都可以再次从broker获得。</p>
</li>
<li><p>可扩展性</p>
<p>Kafka 使用Zookeeper实现动态的集群扩展，不需要更改客户端（生产者和消费者）的配置。broker会在ZK注册并保持相关的元数据更新。而客户端会在ZK上注册相关的watcher，一旦ZK发生变化，客户端能及时做出相应调整。这样可以保证变更broker时，各个broker之间能自动实现负载均衡。</p>
</li>
<li><p>设计目标</p>
<p>高吞吐量</p>
<ul>
<li>数据磁盘持久化：消息不在内存中cache，直接写入到磁盘，充分利用磁盘的顺序读写性能</li>
<li>zero-copy：减少IO操作步骤</li>
<li>支持数据批量发送和拉取</li>
<li>支持数据压缩</li>
<li>Topic划分为多个partition，提高并行处理能力</li>
</ul>
</li>
<li><p>Producer负载均衡和HA机制</p>
<ul>
<li>producer根据用户指定的算法，将消息发送到指定的partition。</li>
<li>存在多个partiiton，每个partition有自己的replica，每个replica分布在不同的Broker节点上。</li>
<li>多个partition需要选取出lead partition，lead partition负责读写，并由zookeeper负责fail over。</li>
<li>通过zookeeper管理broker与consumer的动态加入与离开。</li>
</ul>
</li>
<li><p>Consumer的pull机制</p>
<p>由于broker会持久化数据，broker没有cache压力，因此，consumer比较适合才去pull的方式消费数据：</p>
<ul>
<li>简化kafka设计，降低了难度</li>
<li>Consumer根据消费能力自主控制消息拉取速度</li>
<li>Consumer根据自身情况自主选择消费模式，例如批量，重复消费，从制定partition或位置(offset)开始消费等</li>
</ul>
</li>
<li><p>Consumer与Topic关系以及机制</p>
<p>每个group包含多个consumer。对于topic中的一条特定消息，只会被订阅此Topic每个group中的一个consumer消费，那么一个group中的所有consumer将会交错的消费整个Topic。</p>
<p>如果所有的consumer都具有相同的group（类似JMS queue），消息将有所有的consumer负载均衡</p>
<p>如果所有的consumer都具有不同的group，那么这就是『发布-订阅』，消息将会广播给所有消费者</p>
<p>在Kafka中，一个partition中的消息只会被group中的一个consumer消费（同一时刻）；每个group中consumer消息消费互相独立；<br>一个group是一个『订阅』者，一个Topic中的每个partition只会被一个『订阅』者中的一个consumer消费，但是一个consumer可以同事消费多个partitions中的消息。</p>
<p>Kafka只能保证一个partition中的消息被某个consumer消费是顺序的，但是从Topic角度，当有多个partitions时，消息仍不是全局有序的</p>
<p>一个group中包含多个consumer，这样的话不仅能提高topic中消息的并发消费能力，还能提高『故障容错』性，如果group中的某个consumer失效，那么其消费的partition将会被其他consumer接管</p>
<p>Kafka的设计原理决定，对于一个Topic，同一个group中不能有多于partition个数的consumer同时消费，否则将意味着某些consumer将无法得到消息</p>
</li>
<li><p>Producer均衡算法</p>
<p>Kafka集群中的任何一个broker，都可以向producer提供metadata，这些metadata中包含『集群中存货的servers/partition leaders』，当producer获取到metadata后，会和topic下所有的partition leader保持socker连接；消息由producer直接通过socker发送到broker</p>
<blockquote>
<p>中间不会经过任何『路由层』，即，消息被路由到哪个partition上，是有producer决定的<br>在producer端的配置文件中，可以指定partition的路由方式：『random』，『key-hash』等</p>
</blockquote>
</li>
<li><p>Consumer均衡算法</p>
<p>当一个group中，有consumer加入或者离开时，会触发partitions均衡。均衡的最终目的，是提升topic的并发消费能力。</p>
<ul>
<li>假如topic1,具有如下partitions: P0,P1,P2,P3</li>
<li>加入group中,有如下consumer: C0,C1</li>
<li>首先根据partition索引号对partitions排序: P0,P1,P2,P3</li>
<li>根据consumer.id排序: C0,C1</li>
<li>计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)</li>
<li>然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i <em> M),P((i + 1) </em> M -1)]</li>
</ul>
</li>
<li><p>Broker集群内broker之间replica机制</p>
<p>replication策略是基于partiton，而不是topic</p>
<blockquote>
<p>kafka将每个partition复制到多个server上<br>任何一个partition有一个leader和任意数量的follower<br>备份的数量可以由broker配置文件设定<br>leader处理所有的read-write请求，负责跟踪所有的follower状态，<br>如果follower『落后』太多或者失效，leader会把它从replicas同步列表中删除<br>follower需要和leader保持同步，follower就像一个consumer，消费信息并保存在本地日志中<br>当所有的follower都将一个消息保存成功，此消息才能被认为是『committed』，<br>此时consumer才能消费它，这种策略要求leader和follower之间保持良好的网络环境<br>只要ZK集群存活，即使只存活一个replica，仍可以保证消息的正常发送和接收</p>
</blockquote>
<ul>
<li>Kafka判定一个follower存活的条件<ul>
<li>和ZK保持良好的链接</li>
<li>及时跟进leader，不能落后太多</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果此replicas落后太多，它会继续在leader中fetch数据，然后加入同步列表中，<br>Kafka不会更换宿主，只有这样才能保证replicas足够快，才能保证producer发布消息时接收ACK的延迟较小</p>
</blockquote>
<ul>
<li>当leader失效，需要考虑负载均衡，partition leader较少的broker更有可能成为新的leader，因为<ul>
<li>不能采用『投票多数派』的算法，因为这种算法对于『网络稳定性/投票参与者数量』要求较高</li>
<li>Kafka集群设计中，容忍N-1个replicas失效</li>
<li>每个partiton中所有的replica信息都可以在ZK中获得，那么选择leader是非常简单的</li>
<li>选择follower时需要注意：避免新的leader server上承载的partiton leader的个数过多，否则此server将承受更多的IO压力</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>Producer端直接连接broker列表，从列表中返回TopicMetadataResponse，该Metadata包含Topic下每个partition leader建立socket连接并发送消息。</li>
<li>Broker端使用ZK用来注册broker信息，以及监控partition leader存活性。</li>
<li>Consumer端使用ZK用来注册consumer信息，其中包括consumer消费的partition列表等，同时也用来发现broker列表，并和partition leader建立socket连接，并获取消息。</li>
</ul>
</li>
</ul>
<h4 id="Kafka_u5728Zookeeper_u4E2D_u5B58_u50A8_u7ED3_u6784"><a href="#Kafka_u5728Zookeeper_u4E2D_u5B58_u50A8_u7ED3_u6784" class="headerlink" title="Kafka在Zookeeper中存储结构"></a>Kafka在Zookeeper中存储结构</h4><ul>
<li><p>结构图</p>
<img src="/images/kafka.0.9.0/kafka_in_zk.png" title="kafka在ZK中的存储结构图">
</li>
</ul>
<h4 id="Kafka__u5B89_u88C5_u548C_u914D_u7F6E"><a href="#Kafka__u5B89_u88C5_u548C_u914D_u7F6E" class="headerlink" title="Kafka 安装和配置"></a>Kafka 安装和配置</h4><h4 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li><a href="http://blog.csdn.net/zhongwen7710/article/details/41252649" target="_blank" rel="external">http://blog.csdn.net/zhongwen7710/article/details/41252649</a></li>
<li><a href="http://kafka.apache.org/documentation.html#brokerconfigs" target="_blank" rel="external">http://kafka.apache.org/documentation.html#brokerconfigs</a></li>
</ul>
</div><div class="tags"><a href="/tags/Apache/">Apache</a><a href="/tags/HDFS/">HDFS</a><a href="/tags/Kafka/">Kafka</a></div><div class="post-nav"><a href="/2015/12/10/apache-flume-ng-structure/" class="pre"><i class="icon-previous">apache-flume-ng-structure</i></a><a href="/2015/12/05/kafa-documentation/" class="next">kafka文档简述<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'reasonpun';
var disqus_identifier = '2015/12/08/apache-kafka-structure/';
var disqus_title = 'apache_kafka_structure';
var disqus_url = 'http://reasonpun.com/2015/12/08/apache-kafka-structure/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//reasonpun.disqus.com/count.js" async="async"></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://reasonpun.com"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/">数据挖掘</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/实时计算/">实时计算</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/实时计算/虚拟化/">虚拟化</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据挖掘/实时计算，-源码分析/">实时计算， 源码分析</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统维护/">系统维护</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/系统维护/日志处理/">日志处理</a></li></ul></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Documentation/" style="font-size: 15px;">Documentation</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/Kernel/" style="font-size: 15px;">Kernel</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/HDFS/" style="font-size: 15px;">HDFS</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Logrorate/" style="font-size: 15px;">Logrorate</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Source/" style="font-size: 15px;">Source</a> <a href="/tags/Apache/" style="font-size: 15px;">Apache</a> <a href="/tags/Flume-NG/" style="font-size: 15px;">Flume-NG</a> <a href="/tags/Oryx2/" style="font-size: 15px;">Oryx2</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Spark-Streaming/" style="font-size: 15px;">Spark-Streaming</a> <a href="/tags/Recommendation/" style="font-size: 15px;">Recommendation</a> <a href="/tags/documentation/" style="font-size: 15px;">documentation</a> <a href="/tags/Admin/" style="font-size: 15px;">Admin</a> <a href="/tags/Genetic-Algorithm/" style="font-size: 15px;">Genetic Algorithm</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/12/21/Oryx2-Admin-Docs/">Oryx2 Admin Docs</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/21/Oryx2-Overview/">Oryx2 Overview</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/14/Genetic-Algorithm/">Genetic Algorithm</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/10/apache-flume-ng-structure/">apache-flume-ng-structure</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/08/apache-kafka-structure/">apache_kafka_structure</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/05/kafa-documentation/">kafka文档简述</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/05/linux-shell-获得以前日期/">linux shell 获得以前日期</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/04/spark-in-docker/">spark-in-docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/04/nginx-logrotate/">nginx-logrotate</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/04/spark-source-1/">spark source (1)</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//reasonpun.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://people.csail.mit.edu/matei/" title="Matei Zaharia" target="_blank">Matei Zaharia</a><ul></ul><a href="https://github.com/tensorflow/tensorflow" title="tensorflow" target="_blank">tensorflow</a></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">Tensor Cell.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>