<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"pangz.fun","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4592202470693653" crossorigin="anonymous"></script><meta name="description" content="当您大规模设计和构建应用程序时，您将面临两个重大挑战：可扩展性和稳健性。您应该设计您的服务，以便即使它受到间歇性重负载的影响，它也能继续可靠地运行。以 Apple Store 为例。每年都有数百万 Apple 客户预先注册购买新 iPhone。数百万人同时购买一件商品。"><meta property="og:type" content="article"><meta property="og:title" content="如何使用消息队列、Spring Boot 和 Kubernetes 扩展微服务"><meta property="og:url" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes.html"><meta property="og:site_name" content="酷学小栈"><meta property="og:description" content="当您大规模设计和构建应用程序时，您将面临两个重大挑战：可扩展性和稳健性。您应该设计您的服务，以便即使它受到间歇性重负载的影响，它也能继续可靠地运行。以 Apple Store 为例。每年都有数百万 Apple 客户预先注册购买新 iPhone。数百万人同时购买一件商品。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/1.png"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/2.png"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/3.gif"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/4.gif"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/5.gif"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/6.gif"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/7.gif"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/8.png"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/9.png"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/10.gif"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/11.gif"><meta property="og:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/12.gif"><meta property="article:published_time" content="2022-03-24T03:03:50.000Z"><meta property="article:modified_time" content="2025-01-23T09:09:21.686Z"><meta property="article:author" content="木辛念做梓"><meta property="article:tag" content="Java"><meta property="article:tag" content="SprintBoot"><meta property="article:tag" content="Kubernetes"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/1.png"><link rel="canonical" href="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes.html","path":"How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes.html","title":"如何使用消息队列、Spring Boot 和 Kubernetes 扩展微服务"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>如何使用消息队列、Spring Boot 和 Kubernetes 扩展微服务 | 酷学小栈</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-1HVT1YE421"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-1HVT1YE421","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="酷学小栈" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">酷学小栈</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">还要再走500里</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99-Spring-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">编写 Spring 应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A9%E9%A1%B9%E7%9B%AE%E7%A8%8B%E5%BA%8F%E5%85%88%E7%A9%BA%E8%BD%AC%E4%B8%80%E4%BC%9A%E5%84%BF"><span class="nav-number">2.</span> <span class="nav-text">让项目程序先空转一会儿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JMS-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-number">3.</span> <span class="nav-text">使用 JMS 发送和接收消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E7%9C%81%E9%83%A8%E7%BD%B2%E7%9A%84%E6%89%80%E6%9C%89%E6%97%B6%E9%97%B4%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%B8%93%E6%B3%A8%E4%BA%8E%E7%BC%96%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">节省部署的所有时间都可以专注于编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E5%88%B0-Kubernetes"><span class="nav-number">5.</span> <span class="nav-text">将您的应用程序部署到 Kubernetes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2-ActiveMQ"><span class="nav-number">6.</span> <span class="nav-text">部署 ActiveMQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF"><span class="nav-number">7.</span> <span class="nav-text">部署前端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%AF"><span class="nav-number">8.</span> <span class="nav-text">部署后端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%89%A9%E5%B1%95%E4%BB%A5%E6%BB%A1%E8%B6%B3%E4%B8%8D%E6%96%AD%E5%A2%9E%E9%95%BF%E7%9A%84%E9%9C%80%E6%B1%82"><span class="nav-number">9.</span> <span class="nav-text">手动扩展以满足不断增长的需求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%BC%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8C%87%E6%A0%87"><span class="nav-number">9.1.</span> <span class="nav-text">公开应用程序指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Kubernetes-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8C%87%E6%A0%87"><span class="nav-number">9.2.</span> <span class="nav-text">在 Kubernetes 中使用应用程序指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%A8%E5%B7%B2%E5%87%86%E5%A4%87%E5%A5%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E6%A0%87%E3%80%82"><span class="nav-number">9.3.</span> <span class="nav-text">您已准备好使用指标。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes-%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%89%A9%E5%B1%95%E9%83%A8%E7%BD%B2"><span class="nav-number">9.4.</span> <span class="nav-text">Kubernetes 中的自动扩展部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E6%B5%8B%E8%AF%95"><span class="nav-number">9.5.</span> <span class="nav-text">负载测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E6%AF%94%E8%87%AA%E5%8A%A8%E7%BC%A9%E6%94%BE%E5%AE%9E%E4%BE%8B%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%91%A2%EF%BC%9F-%E8%87%AA%E5%8A%A8%E7%BC%A9%E6%94%BE%E9%9B%86%E7%BE%A4%E3%80%82"><span class="nav-number">9.6.</span> <span class="nav-text">有什么比自动缩放实例更好的呢？ 自动缩放集群。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B"><span class="nav-number">9.7.</span> <span class="nav-text">回顾一下</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">木辛念做梓</p><div class="site-description" itemprop="description">读万卷书，行万里路，胸中脱去尘浊</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">110</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">114</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://io-oi.me/" title="https:&#x2F;&#x2F;io-oi.me" rel="noopener" target="_blank">reuixiy</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pangz.fun/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="木辛念做梓"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="酷学小栈"><meta itemprop="description" content="读万卷书，行万里路，胸中脱去尘浊"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="如何使用消息队列、Spring Boot 和 Kubernetes 扩展微服务 | 酷学小栈"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">如何使用消息队列、Spring Boot 和 Kubernetes 扩展微服务</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-24 11:03:50" itemprop="dateCreated datePublished" datetime="2022-03-24T11:03:50+08:00">2022-03-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-23 17:09:21" itemprop="dateModified" datetime="2025-01-23T17:09:21+08:00">2025-01-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/1.png" title="示意图 width=400"><p>当您大规模设计和构建应用程序时，您将面临两个重大挑战：可扩展性和稳健性。<br>您应该设计您的服务，以便即使它受到间歇性重负载的影响，它也能继续可靠地运行。<br>以 Apple Store 为例。<br>每年都有数百万 Apple 客户预先注册购买新 iPhone。<br>数百万人同时购买一件商品。</p><span id="more"></span><p>如果您将 Apple 商店的流量描绘为随时间变化的每秒请求数，图表可能如下所示：</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/2.png" title="示意图 width=400"><p>现在想象一下，你的任务是构建这样的应用程序。<br>您正在建立一个商店，用户可以在其中购买他们最喜欢的商品。<br>您构建一个微服务来呈现网页并提供静态资产。 您还构建了一个后端 REST API 来处理传入的请求。<br>您希望将这两个组件分开，因为使用相同的 REST API，您可以为网站和移动应用程序提供服务。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/3.gif" title="示意图 width=400"><p>(开始想象)<br>今天是大日子，你的商店上线了。<br>您决定将应用程序扩展到四个前端实例和四个后端实例，因为您预测该网站将比平时更繁忙。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/4.gif" title="示意图 width=400"><p>您开始收到越来越多的流量。<br>前端服务正在处理流量。 但是您注意到连接到数据库的后端正在努力跟上事务的数量。<br>不用担心，您可以将后端的副本数扩展到 8 个。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/5.gif" title="示意图 width=400"><p>您收到的流量更多了，而后端却无法应对。<br>一些服务开始断开连接。 愤怒的客户开始联系你的客服抱（liao）怨（tian）。<br>您的后端越来越乏力，并且丢失了大量的连接。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/6.gif" title="示意图 width=400"><p>你为此损失了一大笔钱，而你的客户则很不高兴。</p><p>您的应用程序并非设计为健壮和高可用性：</p><ul><li>前端和后端是紧密耦合的——事实上它不能处理没有后端的应用程序</li><li>前端和后端必须协同扩展——如果没有足够的后端，你可能会淹没在流量中</li><li>如果后端不可用，您将无法处理传入交易。</li></ul><p>交易损失就是收入损失。<br>所以，你不（zao）得（gan）不（ma）（qu le）重新设计你的架构：用队列解耦前端和后端。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/7.gif" title="示意图 width=400"><p>前端将消息发布到队列，而后端同时处理一条待处理的消息。<br>新架构有一些明显的好处：</p><ul><li>如果后端不可用，则队列充当缓冲区</li><li>如果前端产生的消息多于后端可以处理的消息，则这些消息将缓冲在队列中</li><li>您可以独立于前端扩展后端 - 即您可以拥有数百个前端服务和一个后端实例<br>太好了，但是您如何构建这样的应用程序？<br>您如何设计可以处理数十万个请求的服务？<br>以及如何部署动态扩展的应用程序？<br>在深入了解部署和扩展的细节之前，让我们先关注应用程序。</li></ul><h2 id="编写-Spring-应用程序"><a href="#编写-Spring-应用程序" class="headerlink" title="编写 Spring 应用程序"></a>编写 Spring 应用程序</h2><p>该服务包含三个组件：前端、后端和消息代理。<br>前端是一个带有 Thymeleaf 模板引擎的简单 Spring Boot Web 应用程序。<br>后端是一个从队列中消费消息的工作人员。<br>由于 <a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-jms/">Spring Boot 与 JMS 具有出色的集成</a>，您可以使用它来发送和接收异步消息。<br>您可以在 learnk8s/spring-boot-k8s-hpa 找到一个包含连接到 JMS 的前端和后端应用程序的示例项目。</p><blockquote><p>请注意，该应用程序是用 Java 10 编写的，以利用改进的 Docker 容器集成。</p></blockquote><p>只需要一个代码库，您可以将项目配置为作为前端或后端运行。<br>该应用程序具有：</p><ul><li>可以购买商品的主页</li><li>一个管理面板，您可以在其中检查队列中的消息数量</li><li>一个 /health 端点，用于在应用程序准备好接收流量时发出信号</li><li>一个 /submit 端点，它接收来自表单的提交并在队列中创建消息</li><li>一个 /metrics 端点，用于公开队列中待处理消息的数量（稍后会详细介绍）<br>该应用程序可以在两种模式下运行：<br><strong>作为前端</strong>，应用程序呈现人们可以购买商品的网页。</li></ul><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/8.png" title="示意图 width=400"><p>作为Worker，应用程序等待队列中的消息并处理它们。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/9.png" title="示意图 width=400"><blockquote><p>请注意，在示例项目中，处理是通过使用 Thread.sleep(5000) 等待五秒钟来模拟的。</p></blockquote><p>您可以通过更改 application.yaml 中的值来在任一模式下配置应用程序。</p><h2 id="让项目程序先空转一会儿"><a href="#让项目程序先空转一会儿" class="headerlink" title="让项目程序先空转一会儿"></a>让项目程序先空转一会儿</h2><p>默认情况下，应用程序作为前端和Worker启动。<br>您可以运行该应用程序，并且只要您有一个本地运行的 ActiveMQ 实例，您应该能够购买物品并让系统处理这些物品。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/10.gif" title="示意图 width=400"><p>如果您检查日志，您应该会看到worker正在处理项目。<br>完美！ 编写 Spring Boot 应用程序很容易。<br>一个更有趣的主题是学习如何将 Spring Boot 连接到消息代理。</p><h2 id="使用-JMS-发送和接收消息"><a href="#使用-JMS-发送和接收消息" class="headerlink" title="使用 JMS 发送和接收消息"></a>使用 JMS 发送和接收消息</h2><p>Spring JMS（Java 消息服务）是一种使用标准协议发送和接收消息的强大机制。<br>如果您过去使用过 JDBC API，您应该会发现 JMS API 很熟悉，因为它的工作方式类似。<br>您可以与 JMS 一起使用的最流行的消息代理是 ActiveMQ — 一个开源消息传递服务器。<br>使用这两个组件，您可以使用熟悉的接口 (JMS) 将消息发布到队列 (ActiveMQ)，并使用相同的接口接收消息。<br>更棒的是，Spring Boot 与 JMS 具有出色的集成，因此您可以立即上手。<br>实际上，下面的短类封装了用于与队列交互的逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QueueService</span> <span class="token keyword">implements</span> <span class="token class-name">MessageListener</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> <span class="token constant">LOGGER</span> <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">QueueService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@Autowired</span>
  <span class="token keyword">private</span> <span class="token class-name">JmsTemplate</span> jmsTemplate<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> destination<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"sending message='{}' to destination='{}'"</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span>
    jmsTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>message <span class="token keyword">instanceof</span> <span class="token class-name">ActiveMQTextMessage</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">ActiveMQTextMessage</span> textMessage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ActiveMQTextMessage</span><span class="token punctuation">)</span> message<span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Processing task "</span> <span class="token operator">+</span> textMessage<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Completed task "</span> <span class="token operator">+</span> textMessage<span class="token punctuation">.</span><span class="token function">getText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">JMSException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Message is not a text message "</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>您可以使用 send 方法将消息发布到命名队列。<br>此外，Spring Boot 将为每条传入消息执行 onMessage 方法。<br>最后一块内容要说的是指示 Spring Boot 使用该类。<br>您可以通过在 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jms-annotated-programmatic-registration">Spring Boot 应用程序中注册侦听器</a>来在后台处理消息，如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableJms</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBootApplication</span> <span class="token keyword">implements</span> <span class="token class-name">JmsListenerConfigurer</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Autowired</span>
  <span class="token keyword">private</span> <span class="token class-name">QueueService</span> queueService<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureJmsListeners</span><span class="token punctuation">(</span><span class="token class-name">JmsListenerEndpointRegistrar</span> registrar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SimpleJmsListenerEndpoint</span> endpoint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleJmsListenerEndpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    endpoint<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"myId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    endpoint<span class="token punctuation">.</span><span class="token function">setDestination</span><span class="token punctuation">(</span><span class="token string">"queueName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    endpoint<span class="token punctuation">.</span><span class="token function">setMessageListener</span><span class="token punctuation">(</span>queueService<span class="token punctuation">)</span><span class="token punctuation">;</span>
    registrar<span class="token punctuation">.</span><span class="token function">registerEndpoint</span><span class="token punctuation">(</span>endpoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 id 是消费者的唯一标识符，destination 是队列的名称。<br>请注意您是如何用不到 40 行代码编写出可靠队列的。<br>你一定会爱上 Spring Boot。</p><h2 id="节省部署的所有时间都可以专注于编码"><a href="#节省部署的所有时间都可以专注于编码" class="headerlink" title="节省部署的所有时间都可以专注于编码"></a>节省部署的所有时间都可以专注于编码</h2><p>您验证了应用程序工作正常，终于到了部署它的时候了。<br>此时，您可以启动您的 VPS，安装 Tomcat，并花一些时间编写自定义脚本来测试、构建、打包和部署应用程序。<br>或者您可以写下您希望拥有的内容的描述：一个消息代理和两个使用负载均衡器部署的应用程序。<br>Kubernetes 等编排器可以读取您的清单并配置正确基础架构。<br>由于在基础架构上花费的时间越少，编码时间就越多，这次您将把应用程序部署到 Kubernetes。但在开始之前，您需要一个 Kubernetes 集群。<br>您可以注册 Google Cloud Platform 或 Azure，并使用 Kubernetes 提供的云提供商。或者，您可以在将应用程序迁移到云端之前在本地尝试 Kubernetes。<br>minikube 是一个打包成虚拟机的本地 Kubernetes 集群。如果您使用的是 Windows、Linux 和 Mac，那就太好了，因为创建一个集群需要五分钟。<br>您还应该安装 kubectl，用于连接到您的集群的客户端。<br>您可以从<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/tools/">官方文档</a>中找到有关如何安装 minikube 和 kubectl 的说明。</p><blockquote><p>如果您在 Windows 上运行，您应该查看我们关于如何安装 Kubernetes 和 Docker 的详细指南。</p></blockquote><p>您应该启动一个具有 8GB RAM 和一些额外配置的集群：</p><pre class="line-numbers language-none"><code class="language-none">minikube start \
  --memory 8096 \
  --extra-config=controller-manager.horizontal-pod-autoscaler-upscale-delay=1m \
  --extra-config=controller-manager.horizontal-pod-autoscaler-downscale-delay=2m \
  --extra-config=controller-manager.horizontal-pod-autoscaler-sync-period=10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>请注意，如果您使用的是预先存在的 minikube 实例，您可以通过销毁它并重新创建它来调整 VM 的大小。 仅添加 –memory 8096 不会有任何效果。</p></blockquote><p>验证安装是否成功。<br>您应该会看到以表格形式列出的一些资源。<br>集群已准备就绪，也许您现在应该开始部署？<br>其实，还不可以 😂。<br>你还是需要先准备一些东西。</p><p>部署到 Kubernetes 的应用程序必须打包为容器。 毕竟，Kubernetes 是一个容器编排器，所以它不能原生运行你的 jar。<br>容器类似于胖罐子：它们包含运行应用程序所需的所有依赖项。 甚至 JVM 也是容器的一部分。 所以从技术上讲，它们是一个更胖的胖罐子。<br>将应用程序打包为容器的流行技术是 Docker。</p><blockquote><p>虽然是最受欢迎的，但 Docker 并不是唯一能够运行容器的技术。 其他流行的选项包括 rkt 和 lxd。</p></blockquote><p>如果您没有安装 Docker，可以按照 <a target="_blank" rel="noopener" href="https://docs.docker.com/install/">Docker 官方网站</a>上的说明进行操作。<br>通常，您构建容器并将它们推送到注册表。 这类似于将 jar 发布到 Artifactory 或 Nexus。 但在这种特殊情况下，您将在本地工作并跳过注册表部分。 实际上，您将直接在 minikube 中创建容器镜像。<br>首先，按照此命令打印的说明将 Docker 客户端连接到 minikube：</p><pre class="line-numbers language-none"><code class="language-none">minikube docker-env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>请注意，如果您切换终端，您需要重新连接到 minikube 内部的 Docker 守护进程。 每次使用不同的终端时，都应遵循相同的说明。</p></blockquote><p>并从项目的根目录构建容器镜像：</p><pre class="line-numbers language-none"><code class="language-none">docker build -t spring-k8s-hpa .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以验证映像是否已构建并准备好运行：</p><pre class="line-numbers language-none"><code class="language-none">docker images | grep spring<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完美！<br>集群准备好了，你打包了你的应用程序，也许你现在已经准备好部署了？<br>是的，您终于可以要求 Kubernetes 部署应用程序了。</p><h2 id="将您的应用程序部署到-Kubernetes"><a href="#将您的应用程序部署到-Kubernetes" class="headerlink" title="将您的应用程序部署到 Kubernetes"></a>将您的应用程序部署到 Kubernetes</h2><p>您的应用程序包含三个组件：</p><ul><li>呈现前端的 Spring Boot 应用程序</li><li>ActiveMQ 作为消息代理</li><li>处理事务的 Spring Boot 后端<br>您应该分别部署这三个组件。<br>对于它们中的每一个，您应该创建：</li><li>描述部署什么容器及其配置的部署对象</li><li>一个服务对象，充当部署创建的应用程序的所有实例的负载均衡器<br>部署中应用程序的每个实例都称为 Pod。</li></ul><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/11.gif" title="示意图 width=400"><h2 id="部署-ActiveMQ"><a href="#部署-ActiveMQ" class="headerlink" title="部署 ActiveMQ"></a>部署 ActiveMQ</h2><p>让我们从 ActiveMQ 开始。<br>您应该创建一个包含以下内容的 activemq-deployment.yaml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> queue
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> queue
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> web
        <span class="token key atrule">image</span><span class="token punctuation">:</span> webcenter/activemq<span class="token punctuation">:</span>5.14.3
        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">61616</span>
        <span class="token key atrule">resources</span><span class="token punctuation">:</span>
          <span class="token key atrule">limits</span><span class="token punctuation">:</span>
            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 512Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内容看着挺多的，但读起来还很简单：</p><ul><li>您从名为 webcenter/activemq 的官方注册表中请求了一个 activemq 容器</li><li>容器在端口 61616 上公开消息代理</li><li>为容器分配了 512MB 内存</li><li>你要求一个副本——你的应用程序的一个实例<br>创建一个包含以下内容的 activemq-service.yaml 文件：</li></ul><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1
kind: Service
metadata:
  name: queue
spec:
  ports:
  - port: 61616 
    targetPort: 61616
  selector:
    app: queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>幸运的是，这个模板更短！<br>yaml 内容如下：</p><ul><li>您创建了一个公开端口 61616 的负载均衡器</li><li>传入流量被分发到所有具有 app: queue 类型标签的 Pod（参见上面的部署）</li><li>targetPort 是 Pod 暴露的端口<br>您可以使用以下方法创建资源：</li></ul><pre class="line-numbers language-none"><code class="language-none">kubectl create -f activemq-deployment.yaml
kubectl create -f activemq-service.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>您可以验证数据库的一个实例是否正在运行：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get pods -l=app=queue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><p>创建包含以下内容的 fe-deployment.yaml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> frontend
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend
        <span class="token key atrule">image</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>boot<span class="token punctuation">-</span>hpa
        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent
        <span class="token key atrule">env</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ACTIVEMQ_BROKER_URL
          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"tcp://queue:61616"</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> STORE_ENABLED
          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"true"</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> WORKER_ENABLED
          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"false"</span>
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>
          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>
            <span class="token key atrule">path</span><span class="token punctuation">:</span> /health
            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
        <span class="token key atrule">resources</span><span class="token punctuation">:</span>
          <span class="token key atrule">limits</span><span class="token punctuation">:</span>
            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 512Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>部署看起来很像前一个。<br>不过，有一些新领域：</p><ul><li>有一个部分可以注入环境变量</li><li>有一个 liveness probe 会告诉你应用程序何时准备好接受流量<br>创建一个 fe-service.yaml 文件，内容如下：</li></ul><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">32000</span>
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> frontend
  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>您可以使用以下方法创建资源：</p><pre class="line-numbers language-none"><code class="language-none">kubectl create -f fe-deployment.yaml
kubectl create -f fe-service.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>您可以验证前端应用程序的一个实例是否正在运行：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get pods -l=app=frontend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="部署后端"><a href="#部署后端" class="headerlink" title="部署后端"></a>部署后端</h2><p>创建一个包含以下内容的 backend-deployment.yaml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> backend
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token key atrule">template</span><span class="token punctuation">:</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> backend
      <span class="token key atrule">annotations</span><span class="token punctuation">:</span>
        <span class="token key atrule">prometheus.io/scrape</span><span class="token punctuation">:</span> <span class="token string">'true'</span>
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> backend
        <span class="token key atrule">image</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>boot<span class="token punctuation">-</span>hpa
        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent
        <span class="token key atrule">env</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> ACTIVEMQ_BROKER_URL
          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"tcp://queue:61616"</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> STORE_ENABLED
          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"false"</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> WORKER_ENABLED
          <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"true"</span>
        <span class="token key atrule">ports</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
        <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>
          <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
          <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">5</span>
          <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>
            <span class="token key atrule">path</span><span class="token punctuation">:</span> /health
            <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
        <span class="token key atrule">resources</span><span class="token punctuation">:</span>
          <span class="token key atrule">limits</span><span class="token punctuation">:</span>
            <span class="token key atrule">memory</span><span class="token punctuation">:</span> 512Mi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个包含以下内容的 backend-service.yaml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> backend
  <span class="token key atrule">spec</span><span class="token punctuation">:</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> <span class="token number">31000</span>
      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
    <span class="token key atrule">selector</span><span class="token punctuation">:</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> backend
    <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>您可以使用以下方法创建资源：</p><pre class="line-numbers language-none"><code class="language-none">kubectl create -f backend-deployment.yaml
kubectl create -f backend-service.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>您可以验证后端的一个实例是否正在运行：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get pods -l=app=backend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署完成。</p><p><strong>不过，它真的已经开始工作了吗？</strong></p><p>您可以使用以下命令在浏览器中访问该应用程序：</p><pre class="line-numbers language-none"><code class="language-none">minikube service backend
minikube service frontend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果有效，您应该尝试购买一些物品！<br>worker是否在处理事务？<br>是的，如果有足够的时间，worker 将处理所有待处理的消息。<br>Congratulations!<br>您刚刚将应用程序部署到 Kubernetes！</p><h2 id="手动扩展以满足不断增长的需求"><a href="#手动扩展以满足不断增长的需求" class="headerlink" title="手动扩展以满足不断增长的需求"></a>手动扩展以满足不断增长的需求</h2><p>单个woker可能无法处理大量消息。 事实上，它一次只能处理一条消息。<br>如果您决定购买数千件商品，则需要数小时才能清除队列。<br>此时，您有两个选择：</p><ul><li>您可以手动放大和缩小</li><li>您可以创建自动缩放规则以自动放大或缩小<br>让我们先从基础开始。<br>您可以通过以下方式将后端扩展到三个实例：</li></ul><pre class="line-numbers language-none"><code class="language-none">kubectl scale --replicas=5 deployment/backend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以验证 Kubernetes 是否创建了另外五个实例：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该应用程序可以处理五倍以上的消息。<br>一旦worker排空队列，您可以通过以下方式缩减：</p><pre class="line-numbers language-none"><code class="language-none">kubectl scale --replicas=1 deployment/backend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果您知道什么时候访问您的服务的流量最多，通过手动方式向上和向下扩展会是一种非常棒的体验。<br>如果您不这样做，设置自动缩放器允许应用程序自动缩放而无需人工干预。<br>您只需要定义一些规则。</p><h3 id="公开应用程序指标"><a href="#公开应用程序指标" class="headerlink" title="公开应用程序指标"></a>公开应用程序指标</h3><p>Kubernetes 如何知道何时扩展您的应用程序？<br>很简单，你必须告诉它。<br>自动缩放器通过监控指标来工作。 只有这样它才能增加或减少您的应用程序的实例。<br>因此，您可以将队列的长度作为指标公开，并要求自动缩放器查看该值。 队列中的待处理消息越多，Kubernetes 将创建的应用程序实例就越多。</p><p><strong>那么如何公开这些指标呢？</strong></p><p>应用程序有一个 /metrics 端点来公开队列中的消息数。 如果您尝试访问该页面，您会注意到以下内容：</p><pre class="line-numbers language-none"><code class="language-none"># HELP messages Number of messages in the queue
# TYPE messages gauge
messages 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>应用程序不会将指标公开为 JSON 格式。 格式是纯文本，是公开 <a target="_blank" rel="noopener" href="https://prometheus.io/docs/concepts/metric_types/">Prometheus 指标</a>的标准。 不要担心记住格式。 大多数时候，您将使用 Prometheus 客户端库之一。</p><h3 id="在-Kubernetes-中使用应用程序指标"><a href="#在-Kubernetes-中使用应用程序指标" class="headerlink" title="在 Kubernetes 中使用应用程序指标"></a>在 Kubernetes 中使用应用程序指标</h3><p>您几乎已准备好进行自动缩放——但您应该先安装指标服务器。 事实上，Kubernetes 默认不会从您的应用程序中提取指标。 如果您愿意，您应该启用自定义指标 API。<br>要安装自定义指标 API，您还需要 Prometheus — 一个时间序列数据库。 安装 Custom Metrics API 所需的所有文件都方便地打包在 learnk8s/spring-boot-k8s-hpa 中。<br>您应该下载该存储库的内容并将当前目录更改为该项目的监视文件夹中。</p><pre class="line-numbers language-none"><code class="language-none">cd spring-boot-k8s-hpa/monitoring<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以从那里创建自定义指标 API：</p><pre class="line-numbers language-none"><code class="language-none">kubectl create -f ./metrics-server
kubectl create -f ./namespaces.yaml
kubectl create -f ./prometheus
kubectl create -f ./custom-metrics-api<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>您应该等到以下命令返回自定义指标列表：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1" | jq .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>任务完成！</p><h3 id="您已准备好使用指标。"><a href="#您已准备好使用指标。" class="headerlink" title="您已准备好使用指标。"></a>您已准备好使用指标。</h3><p>事实上，您应该已经找到了队列中消息数量的自定义指标：</p><pre class="line-numbers language-none"><code class="language-none">kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/messages" | jq .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>恭喜，您有一个公开指标的应用程序和一个使用它们的指标服务器。<br>您终于可以启用自动缩放器了！</p><h3 id="Kubernetes-中的自动扩展部署"><a href="#Kubernetes-中的自动扩展部署" class="headerlink" title="Kubernetes 中的自动扩展部署"></a>Kubernetes 中的自动扩展部署</h3><p>Kubernetes 有一个名为 Horizontal Pod Autoscaler 的对象，用于监控部署并向上和向下扩展 Pod 的数量。<br>您将需要其中之一来自动扩展您的实例。<br>您应该创建一个包含以下内容的 hpa.yaml 文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> autoscaling/v2beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> HorizontalPodAutoscaler
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>boot<span class="token punctuation">-</span>hpa
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">scaleTargetRef</span><span class="token punctuation">:</span>
    <span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1
    <span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment
    <span class="token key atrule">name</span><span class="token punctuation">:</span> backend 
  <span class="token key atrule">minReplicas</span><span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token key atrule">maxReplicas</span><span class="token punctuation">:</span> <span class="token number">10</span>
  <span class="token key atrule">metrics</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> Pods
    <span class="token key atrule">pods</span><span class="token punctuation">:</span>
      <span class="token key atrule">metricName</span><span class="token punctuation">:</span> messages
      <span class="token key atrule">targetAverageValue</span><span class="token punctuation">:</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该文件很神秘，所以让我为您翻译一下：<br>Kubernetes 监视 scaleTargetRef 中指定的部署。 在这种情况下，它是worker。<br>您正在使用消息指标来扩展您的 Pod。 当队列中的消息超过 10 条时，Kubernetes 将触发自动缩放。<br>至少，部署应该有两个 Pod。 十个 Pod 是上限。<br>您可以使用以下方法创建资源：</p><pre class="line-numbers language-none"><code class="language-none">kubectl create -f hpa.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交自动缩放器后，您应该注意到后端的副本数为两个。 这是有道理的，因为您要求自动缩放器始终至少运行两个副本。<br>您可以检查触发自动缩放器的条件以及由此生成的事件：</p><pre class="line-numbers language-none"><code class="language-none">kubectl describe hpa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自动扩缩器表明它能够将 Pod 扩展到 2 个，并准备好监控部署。</p><p><strong>令人兴奋的东西，但它有效吗？</strong></p><h3 id="负载测试"><a href="#负载测试" class="headerlink" title="负载测试"></a>负载测试</h3><p>只有一种方法可以知道它是否有效：在队列中创建大量消息。<br>转到前端应用程序并开始添加大量消息。 添加消息时，请使用以下方法监控 Horizontal Pod Autoscaler 的状态：</p><pre class="line-numbers language-none"><code class="language-none">kubectl describe hpa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Pod 的数量从 2 个增加到 4 个，然后是 8 个，最后是 10 个。<br><strong>该应用程序随消息数量而扩展！ 欢呼吧！</strong><br>您刚刚部署了一个完全可扩展的应用程序，该应用程序可根据队列中待处理消息的数量进行扩展。<br>附带说明一下，缩放算法如下：</p><pre class="line-numbers language-none"><code class="language-none">MAX(CURRENT_REPLICAS_LENGTH * 2, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此外，每一次放大都会每分钟重新评估一次，而每两分钟缩小一次。<br>以上都是可以调整的设置。<br>不过，你还没有完成。</p><h3 id="有什么比自动缩放实例更好的呢？-自动缩放集群。"><a href="#有什么比自动缩放实例更好的呢？-自动缩放集群。" class="headerlink" title="有什么比自动缩放实例更好的呢？ 自动缩放集群。"></a>有什么比自动缩放实例更好的呢？ 自动缩放集群。</h3><p>跨节点扩展 Pod 的效果非常好。 但是，如果集群中没有足够的容量来扩展 Pod 怎么办？<br>如果达到峰值容量，Kubernetes 将使 Pod 处于挂起状态并等待更多资源可用。<br>如果您可以使用类似于 Horizontal Pod Autoscaler 但用于节点的自动缩放器，那就太好了。</p><p>您可以拥有一个集群自动扩缩器，在您需要更多资源时向 Kubernetes 集群添加更多节点。</p><img src="/How-to-scale-Microservices-with-Message-Queues-Spring-Boot-and-Kubernetes/12.gif" title="示意图 width=400"><p>集群自动缩放器有不同的形状和大小。 它也是特定于云提供商的。</p><h3 id="回顾一下"><a href="#回顾一下" class="headerlink" title="回顾一下"></a>回顾一下</h3><p>大规模设计应用程序需要仔细规划和测试。<br>基于队列的架构是一种出色的设计模式，可以解耦微服务并确保它们可以独立扩展和部署。<br>虽然您可以推出部署脚本，但利用 Kubernetes 等容器编排器来自动部署和扩展应用程序会更容易。</p></div><footer class="post-footer"><div class="reward-container"><div>你的鼓励是我更新的动力！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="木辛念做梓 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="木辛念做梓 支付宝"> <span>支付宝</span></div></div></div><div class="post-tags"><a href="/tags/Java/" rel="tag"># Java</a> <a href="/tags/SprintBoot/" rel="tag"># SprintBoot</a> <a href="/tags/Kubernetes/" rel="tag"># Kubernetes</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Integrating-Flutterwave-with-a-Flutter-App.html" rel="prev" title="在Flutter中集成Flutterwave"><i class="fa fa-chevron-left"></i> 在Flutter中集成Flutterwave</a></div><div class="post-nav-item"><a href="/Flutter-Flame-%E2%80%94Step-1-Create-your-game.html" rel="next" title="Flutter & Flame — 第 1 步：创建您的游戏">Flutter & Flame — 第 1 步：创建您的游戏 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">木辛念做梓</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">534k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">8:06</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>