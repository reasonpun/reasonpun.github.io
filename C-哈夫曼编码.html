<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"pangz.fun","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4592202470693653" crossorigin="anonymous"></script><meta name="description" content="📚 哈夫曼编码（Huffman Coding）详解1. 什么是哈夫曼编码？哈夫曼编码（Huffman Coding） 是一种广泛使用的数据压缩算法，用于减少数据传输和存储所需的空间。它属于一种前缀编码（Prefix Code），即任意一个字符的编码都不会是另一个字符编码的前缀，避免了解码歧义。"><meta property="og:type" content="article"><meta property="og:title" content="C++哈夫曼编码"><meta property="og:url" content="https://pangz.fun/C-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.html"><meta property="og:site_name" content="酷学小栈"><meta property="og:description" content="📚 哈夫曼编码（Huffman Coding）详解1. 什么是哈夫曼编码？哈夫曼编码（Huffman Coding） 是一种广泛使用的数据压缩算法，用于减少数据传输和存储所需的空间。它属于一种前缀编码（Prefix Code），即任意一个字符的编码都不会是另一个字符编码的前缀，避免了解码歧义。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-01-03T08:57:05.000Z"><meta property="article:modified_time" content="2025-01-23T09:09:20.452Z"><meta property="article:author" content="木辛念做梓"><meta property="article:tag" content="算法 哈夫曼编码"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://pangz.fun/C-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://pangz.fun/C-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.html","path":"C-哈夫曼编码.html","title":"C++哈夫曼编码"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>C++哈夫曼编码 | 酷学小栈</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-1HVT1YE421"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-1HVT1YE421","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="酷学小栈" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">酷学小栈</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">还要再走500里</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li></ul></nav></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%F0%9F%93%9A-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%EF%BC%88Huffman-Coding%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">📚 哈夫曼编码（Huffman Coding）详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1. 什么是哈夫曼编码？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 基本思想</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.2.</span> <span class="nav-text">2. 哈夫曼编码的核心步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.</span> <span class="nav-text">3. 哈夫曼编码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.1.</span> <span class="nav-text">步骤解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%90%88%E5%B9%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.1. 合并节点的核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.2. 详细示例解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.4.</span> <span class="nav-text">示例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%BD%9C%E4%B8%BA%E7%8B%AC%E7%AB%8B%E8%8A%82%E7%82%B9"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.2.1 第一步：将每个字符作为独立节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E9%80%89%E6%8B%A9%E9%A2%91%E7%8E%87%E6%9C%80%E5%B0%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.2.2 第二步：选择频率最小的两个节点进行合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%86%8D%E6%AC%A1%E9%80%89%E6%8B%A9%E9%A2%91%E7%8E%87%E6%9C%80%E5%B0%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.2.3 第三步：再次选择频率最小的两个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E7%BB%A7%E7%BB%AD%E9%80%89%E6%8B%A9%E9%A2%91%E7%8E%87%E6%9C%80%E5%B0%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.2.4 第四步：继续选择频率最小的两个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%90%88%E5%B9%B6%E5%89%A9%E4%B8%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%B0%8F%E8%8A%82%E7%82%B9"><span class="nav-number">1.3.9.</span> <span class="nav-text">3.2.5 第五步：合并剩下的两个最小节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-%E7%AC%AC%E5%85%AD%E6%AD%A5%EF%BC%9A%E5%90%88%E5%B9%B6%E6%9C%80%E5%90%8E%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.3.10.</span> <span class="nav-text">3.2.6 第六步：合并最后两个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%94%9F%E6%88%90%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">1.3.11.</span> <span class="nav-text">3.3. 生成哈夫曼编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99"><span class="nav-number">1.3.12.</span> <span class="nav-text">3.3.1 编码规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E7%BC%96%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">1.3.13.</span> <span class="nav-text">3.3.2 编码生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%90%88%E5%B9%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.3.14.</span> <span class="nav-text">3.4. 合并节点的贪心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E9%80%89%E6%8B%A9%E6%9C%80%E5%B0%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E5%90%88%E5%B9%B6%EF%BC%9F"><span class="nav-number">1.3.15.</span> <span class="nav-text">为什么每次选择最小的两个节点合并？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E4%BB%A3%E7%A0%81%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.3.16.</span> <span class="nav-text">3.5. 代码回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%88%E5%90%88%E5%B9%B6%E8%8A%82%E7%82%B9%E9%83%A8%E5%88%86%EF%BC%89"><span class="nav-number">1.3.17.</span> <span class="nav-text">核心逻辑（合并节点部分）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.18.</span> <span class="nav-text">3.6. 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81-C-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">4. 哈夫曼编码 C++ 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 代码示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 代码解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E7%A4%BA%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 示例输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.5.</span> <span class="nav-text">5. 哈夫曼编码的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9C%85-%E4%BC%98%E7%82%B9"><span class="nav-number">1.5.1.</span> <span class="nav-text">✅ 优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%8C-%E7%BC%BA%E7%82%B9"><span class="nav-number">1.5.2.</span> <span class="nav-text">❌ 缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.</span> <span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%F0%9F%93%9A-%E6%B3%A8%EF%BC%9A%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%88Min-Heap%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">📚 注：小顶堆（Min Heap）详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">1. 什么是小顶堆？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B0%8F%E9%A1%B6%E5%A0%86%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">2. 小顶堆的关键特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B0%8F%E9%A1%B6%E5%A0%86%E4%B8%8E%E5%A4%A7%E9%A1%B6%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">3. 小顶堆与大顶堆的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-C-%E4%B8%AD%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E5%B0%8F%E9%A1%B6%E5%A0%86"><span class="nav-number">2.4.</span> <span class="nav-text">4. C++ 中的优先队列与小顶堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-std-priority-queue"><span class="nav-number">2.4.1.</span> <span class="nav-text">4.1 std::priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%B0%8F%E9%A1%B6%E5%A0%86%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.4.2.</span> <span class="nav-text">4.2 小顶堆示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E4%BD%BF%E7%94%A8-std-greater-%E5%AE%9E%E7%8E%B0%E5%B0%8F%E9%A1%B6%E5%A0%86"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">示例 1：使用 std::greater 实现小顶堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">示例 2：使用自定义比较器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%B0%8F%E9%A1%B6%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.5.</span> <span class="nav-text">5. 小顶堆的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.6.</span> <span class="nav-text">6. 总结</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">木辛念做梓</p><div class="site-description" itemprop="description">读万卷书，行万里路，胸中脱去尘浊</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">110</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">114</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://io-oi.me/" title="https:&#x2F;&#x2F;io-oi.me" rel="noopener" target="_blank">reuixiy</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://pangz.fun/C-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="木辛念做梓"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="酷学小栈"><meta itemprop="description" content="读万卷书，行万里路，胸中脱去尘浊"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="C++哈夫曼编码 | 酷学小栈"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++哈夫曼编码</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-01-03 16:57:05" itemprop="dateCreated datePublished" datetime="2025-01-03T16:57:05+08:00">2025-01-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-01-23 17:09:20" itemprop="dateModified" datetime="2025-01-23T17:09:20+08:00">2025-01-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="📚-哈夫曼编码（Huffman-Coding）详解"><a href="#📚-哈夫曼编码（Huffman-Coding）详解" class="headerlink" title="📚 哈夫曼编码（Huffman Coding）详解"></a>📚 <strong>哈夫曼编码（Huffman Coding）详解</strong></h1><h2 id="1-什么是哈夫曼编码？"><a href="#1-什么是哈夫曼编码？" class="headerlink" title="1. 什么是哈夫曼编码？"></a><strong>1. 什么是哈夫曼编码？</strong></h2><p><strong>哈夫曼编码（Huffman Coding）</strong> 是一种广泛使用的<strong>数据压缩算法</strong>，用于减少数据传输和存储所需的空间。它属于一种<strong>前缀编码</strong>（Prefix Code），即任意一个字符的编码都不会是另一个字符编码的前缀，避免了解码歧义。</p><span id="more"></span><h3 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1 应用场景"></a><strong>1.1 应用场景</strong></h3><ul><li>文件压缩（例如 ZIP、GZIP 等）</li><li>图像压缩（例如 JPEG）</li><li>网络通信传输数据</li></ul><h3 id="1-2-基本思想"><a href="#1-2-基本思想" class="headerlink" title="1.2 基本思想"></a><strong>1.2 基本思想</strong></h3><ul><li>频率（或权重）越高的字符使用的<strong>编码越短</strong>，频率越低的字符使用的<strong>编码越长</strong>。</li><li>使用<strong>二叉树</strong>构建编码，频率较小的字符处于树的底部，频率较大的字符靠近根节点。</li></ul><h2 id="2-哈夫曼编码的核心步骤"><a href="#2-哈夫曼编码的核心步骤" class="headerlink" title="2. 哈夫曼编码的核心步骤"></a><strong>2. 哈夫曼编码的核心步骤</strong></h2><ol><li><p><strong>统计字符频率</strong></p><ul><li>统计每个字符在数据中的出现次数。</li></ul></li><li><p><strong>构建哈夫曼树</strong></p><ul><li>将每个字符作为一个<strong>叶子节点</strong>，频率作为节点权重。</li><li>取出<strong>频率最小的两个节点</strong>，合并成一个新的节点，新的节点的频率是两者之和。</li><li>重复此过程，直到所有节点合并成一棵树。</li></ul></li><li><p><strong>生成编码</strong></p><ul><li>从根节点开始，<strong>左子树编码为 0，右子树编码为 1</strong>。</li><li>遍历整棵树，为每个字符生成对应的二进制编码。</li></ul></li><li><p><strong>编码与解码</strong></p><ul><li>使用生成的二进制编码进行数据压缩。</li><li>解码时，使用哈夫曼树进行还原。</li></ul></li></ol><h2 id="3-哈夫曼编码示例"><a href="#3-哈夫曼编码示例" class="headerlink" title="3. 哈夫曼编码示例"></a><strong>3. 哈夫曼编码示例</strong></h2><h3 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a><strong>步骤解析</strong></h3><h3 id="3-1-合并节点的核心思想"><a href="#3-1-合并节点的核心思想" class="headerlink" title="3.1. 合并节点的核心思想"></a><strong>3.1. 合并节点的核心思想</strong></h3><ol><li><p><strong>每次选择频率最小的两个节点</strong></p><ul><li>将这两个节点作为新节点的左右子节点。</li><li>新节点的频率是这两个节点的频率之和。</li></ul></li><li><p><strong>将新节点加入到集合中</strong></p><ul><li>将合并后的新节点重新加入到节点集合中，继续进行下一轮合并。</li></ul></li><li><p><strong>重复以上步骤，直到只剩下一个节点</strong></p><ul><li>最终，所有节点将合并成一棵<strong>哈夫曼树</strong>。</li><li>根节点的频率是所有字符频率的总和。</li></ul></li></ol><h3 id="3-2-详细示例解析"><a href="#3-2-详细示例解析" class="headerlink" title="3.2. 详细示例解析"></a><strong>3.2. 详细示例解析</strong></h3><h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a><strong>示例数据</strong></h3><p>假设有以下字符及其频率：</p><table><thead><tr><th>字符</th><th>频率</th></tr></thead><tbody><tr><td>a</td><td>5</td></tr><tr><td>b</td><td>9</td></tr><tr><td>c</td><td>12</td></tr><tr><td>d</td><td>13</td></tr><tr><td>e</td><td>16</td></tr><tr><td>f</td><td>45</td></tr></tbody></table><h3 id="3-2-1-第一步：将每个字符作为独立节点"><a href="#3-2-1-第一步：将每个字符作为独立节点" class="headerlink" title="3.2.1 第一步：将每个字符作为独立节点"></a><strong>3.2.1 第一步：将每个字符作为独立节点</strong></h3><pre class="line-numbers language-none"><code class="language-none">a(5), b(9), c(12), d(13), e(16), f(45)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-2-第二步：选择频率最小的两个节点进行合并"><a href="#3-2-2-第二步：选择频率最小的两个节点进行合并" class="headerlink" title="3.2.2 第二步：选择频率最小的两个节点进行合并"></a><strong>3.2.2 第二步：选择频率最小的两个节点进行合并</strong></h3><ul><li>选择 <code>a(5)</code> 和 <code>b(9)</code>，合并成新节点，频率为 <code>5 + 9 = 14</code>。</li></ul><pre class="line-numbers language-none"><code class="language-none">  (a+b)(14)
  /      \
a(5)    b(9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>将新节点 <code>(a+b)(14)</code> 加回节点集合：</li></ul><pre class="line-numbers language-none"><code class="language-none">(a+b)(14), c(12), d(13), e(16), f(45)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-3-第三步：再次选择频率最小的两个节点"><a href="#3-2-3-第三步：再次选择频率最小的两个节点" class="headerlink" title="3.2.3 第三步：再次选择频率最小的两个节点"></a><strong>3.2.3 第三步：再次选择频率最小的两个节点</strong></h3><ul><li>选择 <code>c(12)</code> 和 <code>d(13)</code>，合并成新节点，频率为 <code>12 + 13 = 25</code>。</li></ul><pre class="line-numbers language-none"><code class="language-none">  (c+d)(25)
  /      \
c(12)   d(13)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>将新节点 <code>(c+d)(25)</code> 加回节点集合：</li></ul><pre class="line-numbers language-none"><code class="language-none">(a+b)(14), (c+d)(25), e(16), f(45)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-4-第四步：继续选择频率最小的两个节点"><a href="#3-2-4-第四步：继续选择频率最小的两个节点" class="headerlink" title="3.2.4 第四步：继续选择频率最小的两个节点"></a><strong>3.2.4 第四步：继续选择频率最小的两个节点</strong></h3><ul><li>选择 <code>(a+b)(14)</code> 和 <code>e(16)</code>，合并成新节点，频率为 <code>14 + 16 = 30</code>。</li></ul><pre class="line-numbers language-none"><code class="language-none">      ((a+b)+e)(30)
      /       \
  (a+b)(14)   e(16)
  /     \
a(5)   b(9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将新节点 <code>(a+b+e)(30)</code> 加回节点集合：</li></ul><pre class="line-numbers language-none"><code class="language-none">(c+d)(25), ((a+b)+e)(30), f(45)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-5-第五步：合并剩下的两个最小节点"><a href="#3-2-5-第五步：合并剩下的两个最小节点" class="headerlink" title="3.2.5 第五步：合并剩下的两个最小节点"></a><strong>3.2.5 第五步：合并剩下的两个最小节点</strong></h3><ul><li>选择 <code>(c+d)(25)</code> 和 <code>((a+b)+e)(30)</code>，合并成新节点，频率为 <code>25 + 30 = 55</code>。</li></ul><pre class="line-numbers language-none"><code class="language-none">      ((c+d)+((a+b)+e))(55)
      /                \
  (c+d)(25)        ((a+b)+e)(30)
  /     \           /       \
c(12)  d(13)   (a+b)(14)   e(16)
                    /  \
                  a(5) b(9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将新节点加入集合：</li></ul><pre class="line-numbers language-none"><code class="language-none">((c+d)+((a+b)+e))(55), f(45)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-6-第六步：合并最后两个节点"><a href="#3-2-6-第六步：合并最后两个节点" class="headerlink" title="3.2.6 第六步：合并最后两个节点"></a><strong>3.2.6 第六步：合并最后两个节点</strong></h3><ul><li>合并 <code>f(45)</code> 和 <code>((c+d)+((a+b)+e))(55)</code>，频率为 <code>45 + 55 = 100</code>。</li></ul><pre class="line-numbers language-none"><code class="language-none">   ROOT(100)
   /       \
f(45)   ((c+d)+((a+b)+e))(55)
           /                \
       (c+d)(25)       ((a+b)+e)(30)
       /     \           /       \
     c(12)  d(13)   (a+b)(14)   e(16)
                         /  \
                       a(5) b(9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-生成哈夫曼编码"><a href="#3-3-生成哈夫曼编码" class="headerlink" title="3.3. 生成哈夫曼编码"></a><strong>3.3. 生成哈夫曼编码</strong></h3><h3 id="3-3-1-编码规则"><a href="#3-3-1-编码规则" class="headerlink" title="3.3.1 编码规则"></a><strong>3.3.1 编码规则</strong></h3><ul><li><strong>向左走，编码为 0</strong></li><li><strong>向右走，编码为 1</strong></li></ul><h3 id="3-3-2-编码生成"><a href="#3-3-2-编码生成" class="headerlink" title="3.3.2 编码生成"></a><strong>3.3.2 编码生成</strong></h3><ul><li><code>f</code> → <code>0</code></li><li><code>c</code> → <code>100</code></li><li><code>d</code> → <code>101</code></li><li><code>a</code> → <code>1100</code></li><li><code>b</code> → <code>1101</code></li><li><code>e</code> → <code>111</code></li></ul><h3 id="3-4-合并节点的贪心思想"><a href="#3-4-合并节点的贪心思想" class="headerlink" title="3.4. 合并节点的贪心思想"></a><strong>3.4. 合并节点的贪心思想</strong></h3><h3 id="为什么每次选择最小的两个节点合并？"><a href="#为什么每次选择最小的两个节点合并？" class="headerlink" title="为什么每次选择最小的两个节点合并？"></a><strong>为什么每次选择最小的两个节点合并？</strong></h3><ol><li><p><strong>减少树的高度</strong></p><ul><li>频率小的节点放在树的底层，减少高频字符的路径长度。</li></ul></li><li><p><strong>保证整体编码长度最小</strong></p><ul><li>频率越高的字符路径越短，减少整体编码的长度。</li></ul></li><li><p><strong>贪心选择局部最优解</strong></p><ul><li>每次选择最小的两个节点合并，最终得到整体最优的哈夫曼树。</li></ul></li></ol><h3 id="3-5-代码回顾"><a href="#3-5-代码回顾" class="headerlink" title="3.5. 代码回顾"></a><strong>3.5. 代码回顾</strong></h3><h3 id="核心逻辑（合并节点部分）"><a href="#核心逻辑（合并节点部分）" class="headerlink" title="核心逻辑（合并节点部分）"></a><strong>核心逻辑（合并节点部分）</strong></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    HuffmanNode<span class="token operator">*</span> left <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    HuffmanNode<span class="token operator">*</span> right <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 合并两个最小频率节点</span>
    HuffmanNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">HuffmanNode</span><span class="token punctuation">(</span><span class="token char">'$'</span><span class="token punctuation">,</span> left<span class="token operator">-&gt;</span>freq <span class="token operator">+</span> right<span class="token operator">-&gt;</span>freq<span class="token punctuation">)</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
    newNode<span class="token operator">-&gt;</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>

    <span class="token comment">// 将新节点加入小顶堆</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>每次取出<strong>两个最小节点</strong>。</li><li>合并为新节点，新的频率是两者之和。</li><li>将新节点重新插入到<strong>小顶堆</strong>中。</li></ul><h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6. 总结"></a><strong>3.6. 总结</strong></h3><ol><li><strong>每次合并最小的两个节点</strong>，确保局部最优。</li><li><strong>重复合并，直到构建出一棵完整的哈夫曼树</strong>。</li><li><strong>使用二叉树的左 0 右 1 规则生成编码</strong>。</li><li><strong>小顶堆保证每次能够快速找到最小的两个节点</strong>。</li></ol><h2 id="4-哈夫曼编码-C-实现"><a href="#4-哈夫曼编码-C-实现" class="headerlink" title="4. 哈夫曼编码 C++ 实现"></a><strong>4. 哈夫曼编码 C++ 实现</strong></h2><h3 id="4-1-代码示例"><a href="#4-1-代码示例" class="headerlink" title="4.1 代码示例"></a><strong>4.1 代码示例</strong></h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 定义哈夫曼树的节点</span>
<span class="token keyword">struct</span> <span class="token class-name">HuffmanNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> data<span class="token punctuation">;</span>        <span class="token comment">// 字符</span>
    <span class="token keyword">int</span> freq<span class="token punctuation">;</span>         <span class="token comment">// 频率</span>
    HuffmanNode <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>

    <span class="token function">HuffmanNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> d<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">freq</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 比较函数，用于优先队列</span>
<span class="token keyword">struct</span> <span class="token class-name">Compare</span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>HuffmanNode<span class="token operator">*</span> l<span class="token punctuation">,</span> HuffmanNode<span class="token operator">*</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> l<span class="token operator">-&gt;</span>freq <span class="token operator">&gt;</span> r<span class="token operator">-&gt;</span>freq<span class="token punctuation">;</span> <span class="token comment">// 小顶堆</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 递归打印哈夫曼编码</span>
<span class="token keyword">void</span> <span class="token function">printCodes</span><span class="token punctuation">(</span>HuffmanNode<span class="token operator">*</span> root<span class="token punctuation">,</span> string code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token comment">// 如果是叶子节点，打印字符和对应编码</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>data <span class="token operator">!=</span> <span class="token char">'$'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-&gt;</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> code <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printCodes</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> code <span class="token operator">+</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printCodes</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> code <span class="token operator">+</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 哈夫曼编码主函数</span>
<span class="token keyword">void</span> <span class="token function">HuffmanCoding</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> freqTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    priority_queue<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">*</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> Compare<span class="token operator">&gt;</span> minHeap<span class="token punctuation">;</span>

    <span class="token comment">// 将字符和频率加入最小堆</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> pair <span class="token operator">:</span> freqTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">HuffmanNode</span><span class="token punctuation">(</span>pair<span class="token punctuation">.</span>first<span class="token punctuation">,</span> pair<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 构建哈夫曼树</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        HuffmanNode<span class="token operator">*</span> left <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        HuffmanNode<span class="token operator">*</span> right <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建一个新节点，将左右子节点合并</span>
        HuffmanNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">HuffmanNode</span><span class="token punctuation">(</span><span class="token char">'$'</span><span class="token punctuation">,</span> left<span class="token operator">-&gt;</span>freq <span class="token operator">+</span> right<span class="token operator">-&gt;</span>freq<span class="token punctuation">)</span><span class="token punctuation">;</span>
        newNode<span class="token operator">-&gt;</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
        newNode<span class="token operator">-&gt;</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>

        minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 打印哈夫曼编码</span>
    <span class="token function">printCodes</span><span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> freqTable <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token char">'d'</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token char">'e'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token char">'f'</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token function">HuffmanCoding</span><span class="token punctuation">(</span>freqTable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-代码解析"><a href="#4-2-代码解析" class="headerlink" title="4.2 代码解析"></a><strong>4.2 代码解析</strong></h3><ol><li><p><strong>定义节点结构体</strong></p><ul><li>每个节点包含字符、频率、左右子节点指针。</li></ul></li><li><p><strong>使用优先队列（小顶堆）</strong></p><ul><li>频率小的节点优先出队。</li></ul></li><li><p><strong>构建哈夫曼树</strong></p><ul><li>每次合并两个频率最小的节点，形成新节点并重新加入堆中。</li></ul></li><li><p><strong>生成编码</strong></p><ul><li>使用<strong>递归遍历</strong>生成每个字符的编码。</li></ul></li><li><p><strong>打印编码</strong></p><ul><li>对叶子节点进行编码输出。</li></ul></li></ol><h3 id="4-3-示例输出"><a href="#4-3-示例输出" class="headerlink" title="4.3 示例输出"></a><strong>4.3 示例输出</strong></h3><pre class="line-numbers language-none"><code class="language-none">f: 0
c: 100
d: 101
a: 1100
b: 1101
e: 111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-哈夫曼编码的优缺点"><a href="#5-哈夫曼编码的优缺点" class="headerlink" title="5. 哈夫曼编码的优缺点"></a><strong>5. 哈夫曼编码的优缺点</strong></h2><h3 id="✅-优点"><a href="#✅-优点" class="headerlink" title="✅ 优点"></a>✅ <strong>优点</strong></h3><ol><li>高效的压缩算法。</li><li>适用于字符频率分布不均匀的场景。</li><li>前缀编码，无解码歧义。</li></ol><h3 id="❌-缺点"><a href="#❌-缺点" class="headerlink" title="❌ 缺点"></a>❌ <strong>缺点</strong></h3><ol><li>频率统计可能较耗时。</li><li>对于字符频率相对均匀的数据，压缩效果不显著。</li><li>在动态数据流中编码效率较低。</li></ol><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h2><ul><li>哈夫曼编码是一种<strong>贪心算法</strong>，在每一步都选择频率最小的节点进行合并。</li><li>构建哈夫曼树的核心是<strong>小顶堆</strong>，以确保频率最小的节点被优先处理。</li><li>哈夫曼编码是一种<strong>无前缀编码</strong>，有效避免了编码歧义。</li></ul><p>通过这个示例和讲解，相信你已经对哈夫曼编码有了清晰的理解！🚀</p><h1 id="📚-注：小顶堆（Min-Heap）详解"><a href="#📚-注：小顶堆（Min-Heap）详解" class="headerlink" title="📚 注：小顶堆（Min Heap）详解"></a>📚 <strong>注：小顶堆（Min Heap）详解</strong></h1><h2 id="1-什么是小顶堆？"><a href="#1-什么是小顶堆？" class="headerlink" title="1. 什么是小顶堆？"></a><strong>1. 什么是小顶堆？</strong></h2><p><strong>小顶堆（Min Heap）</strong> 是一种<strong>二叉堆</strong>（Binary Heap），它满足以下两个特性：</p><ol><li><p><strong>完全二叉树</strong>：</p><ul><li>小顶堆必须是一棵<strong>完全二叉树</strong>，即每一层都被完全填满，除了最后一层可以不满，但节点必须从左到右连续排列。</li></ul></li><li><p><strong>堆序性（堆性质）</strong>：</p><ul><li><strong>根节点的值小于或等于其所有子节点的值</strong>。</li><li>对于每一个节点 ( i )：</li></ul><pre class="line-numbers language-none"><code class="language-none">A[i] &lt;= A[2i+1] // (左子节点)
A[i] &lt;= A[2i+2] // (右子节点)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="2-小顶堆的关键特性"><a href="#2-小顶堆的关键特性" class="headerlink" title="2. 小顶堆的关键特性"></a><strong>2. 小顶堆的关键特性</strong></h2><ol><li><p><strong>根节点</strong></p><ul><li>堆顶（根节点）总是存储<strong>最小的元素</strong>。</li></ul></li><li><p><strong>插入操作</strong></p><ul><li>新元素插入到堆的末尾，然后进行<strong>上浮操作</strong>，以确保堆的性质保持不变。</li></ul></li><li><p><strong>删除操作</strong></p><ul><li>通常删除<strong>根节点</strong>（最小值）。</li><li>用堆的最后一个节点替换根节点，然后进行<strong>下沉操作</strong>，以重新维持堆的性质。</li></ul></li><li><p><strong>优先队列</strong></p><ul><li>小顶堆常用于实现<strong>优先队列</strong>（Priority Queue），保证每次出队的都是当前最小的元素。</li></ul></li></ol><h2 id="3-小顶堆与大顶堆的区别"><a href="#3-小顶堆与大顶堆的区别" class="headerlink" title="3. 小顶堆与大顶堆的区别"></a><strong>3. 小顶堆与大顶堆的区别</strong></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>小顶堆 (Min Heap)</strong></th><th><strong>大顶堆 (Max Heap)</strong></th></tr></thead><tbody><tr><td><strong>根节点</strong></td><td>最小值</td><td>最大值</td></tr><tr><td><strong>子节点</strong></td><td>子节点值 &gt;= 根节点值</td><td>子节点值 &lt;= 根节点值</td></tr><tr><td><strong>应用场景</strong></td><td>哈夫曼编码、最短路径算法</td><td>堆排序、最大值查找</td></tr></tbody></table><h2 id="4-C-中的优先队列与小顶堆"><a href="#4-C-中的优先队列与小顶堆" class="headerlink" title="4. C++ 中的优先队列与小顶堆"></a><strong>4. C++ 中的优先队列与小顶堆</strong></h2><h3 id="4-1-std-priority-queue"><a href="#4-1-std-priority-queue" class="headerlink" title="4.1 std::priority_queue"></a><strong>4.1 <code>std::priority_queue</code></strong></h3><p>在 C++ 中，默认的 <code>std::priority_queue</code> 是<strong>大顶堆</strong>，即最大值优先。</p><p>要实现<strong>小顶堆</strong>，可以使用以下两种方式：</p><ol><li><strong>自定义比较器</strong></li><li><strong>使用 <code>std::greater</code> 函数对象</strong></li></ol><h3 id="4-2-小顶堆示例"><a href="#4-2-小顶堆示例" class="headerlink" title="4.2 小顶堆示例"></a><strong>4.2 小顶堆示例</strong></h3><h4 id="示例-1：使用-std-greater-实现小顶堆"><a href="#示例-1：使用-std-greater-实现小顶堆" class="headerlink" title="示例 1：使用 std::greater 实现小顶堆"></a><strong>示例 1：使用 <code>std::greater</code> 实现小顶堆</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 greater&lt;int&gt; 实现小顶堆</span>
    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> minHeap<span class="token punctuation">;</span>

    <span class="token comment">// 插入元素</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 取出最小元素</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"小顶堆的元素出队顺序："</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minHeap<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>✅ 输出：</strong></p><pre class="line-numbers language-none"><code class="language-none">小顶堆的元素出队顺序：1 5 10 20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="示例-2：使用自定义比较器"><a href="#示例-2：使用自定义比较器" class="headerlink" title="示例 2：使用自定义比较器"></a><strong>示例 2：使用自定义比较器</strong></h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">// 自定义比较器</span>
<span class="token keyword">struct</span> <span class="token class-name">Compare</span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a <span class="token operator">&gt;</span> b<span class="token punctuation">;</span> <span class="token comment">// a 大于 b 时，a 排在后面</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> Compare<span class="token operator">&gt;</span> minHeap<span class="token punctuation">;</span>

    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"小顶堆的元素出队顺序："</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minHeap<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>✅ 输出：</strong></p><pre class="line-numbers language-none"><code class="language-none">小顶堆的元素出队顺序：1 3 8 15<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="5-小顶堆的应用场景"><a href="#5-小顶堆的应用场景" class="headerlink" title="5. 小顶堆的应用场景"></a><strong>5. 小顶堆的应用场景</strong></h2><ol><li><strong>哈夫曼编码</strong><ul><li>使用小顶堆确保每次选择权重最小的两个节点进行合并。</li></ul></li><li><strong>Dijkstra 算法</strong><ul><li>寻找最短路径时，使用小顶堆优先选择当前路径最短的节点。</li></ul></li><li><strong>Top K 问题</strong><ul><li>在大量数据中快速找到前 K 小的元素。</li></ul></li><li><strong>事件驱动仿真</strong><ul><li>模拟器中按照事件发生的时间顺序处理事件。</li></ul></li></ol><h2 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h2><ul><li><strong>小顶堆</strong>是一种<strong>完全二叉树</strong>，每个父节点的值都小于或等于其子节点的值。</li><li>在 C++ 中，可以使用 <code>std::priority_queue</code> 配合 <code>std::greater</code> 或自定义比较器来实现小顶堆。</li><li>小顶堆的核心操作包括<strong>插入（上浮）</strong>、<strong>删除（下沉）</strong>。</li><li>主要应用于<strong>优先队列</strong>、<strong>哈夫曼编码</strong>、<strong>Dijkstra 算法</strong>等场景。</li></ul></div><footer class="post-footer"><div class="reward-container"><div>你的鼓励是我更新的动力！</div><button>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.png" alt="木辛念做梓 微信"> <span>微信</span></div><div><img src="/images/alipay.png" alt="木辛念做梓 支付宝"> <span>支付宝</span></div></div></div><div class="post-tags"><a href="/tags/%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" rel="tag"># 算法 哈夫曼编码</a></div><div class="post-nav"><div class="post-nav-item"><a href="/C-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html" rel="prev" title="C++贪心算法"><i class="fa fa-chevron-left"></i> C++贪心算法</a></div><div class="post-nav-item"><a href="/C-Dijkstra%E7%AE%97%E6%B3%95.html" rel="next" title="C++Dijkstra算法">C++Dijkstra算法 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">木辛念做梓</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">534k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">8:06</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="moon-menu"><div class="moon-menu-items"><div id="moon-menu-item-back2bottom" class="moon-menu-item"><i class="fas fa-chevron-down"></i></div><div id="moon-menu-item-back2top" class="moon-menu-item"><i class="fas fa-chevron-up"></i></div></div><div class="moon-menu-button"><svg class="moon-menu-bg"><circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle><circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle></svg><div class="moon-menu-content"><div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div><div class="moon-menu-text"></div></div></div></div><script src="/js/injector.js"></script></body></html>